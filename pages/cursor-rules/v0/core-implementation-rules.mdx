---
title: "V0 Core Implementation Rules"
navOrder: 1
---

# Rin V0 Core Implementation Rules

This page contains all the Cursor rules you need to implement the Developer & Testing Tools for Rin V0 as outlined in the [Core Implementation Guide](/v0/rin-v0-core-implementation-guide) guide.

## Setting Up Cursor Rules

To use these rules in your project, follow these steps:

1. Create a rules directory in your project:
```bash
mkdir -p .cursor/rules
```

2. For each rule below, create a corresponding <code>.cursorignore</code> file in the <code>.cursor/rules</code> directory with the rule content.

For example, to set up the Project Setup rule:
```bash
# Copy the Project Setup rule content
# Create the rule file
touch .cursor/rules/Rin-v0-step1-setup.cursorignore
# Paste the rule content into the file
```

3. You can now use these rules in Cursor to guide your development process. Cursor will automatically apply these rules when you work on relevant files.

## Project Setup Rule

This rule helps you with the initial project setup for the Rin V0 prototype, a Python-based voice-first AI assistant.

<details>
<summary>**Click to see the complete Project Setup rule**</summary>

```
# Rin V0 Project Setup Rule
# This rule helps with setting up the initial project structure and dependencies

# Define which files this rule applies to
*.py
*.env
setup.py
pyproject.toml
requirements.txt
.env

# Rule content below
When helping with the Rin V0 Step 1 project setup:

1. Project Structure Guidelines:
   - Follow the specified directory structure:
     - rin-cli/
       - rin/
         - __init__.py
         - cli.py (CLI entry point)
         - core.py (Core application logic)
         - llm.py (Language model integration)
         - tts.py (Text-to-speech capabilities)
         - stt.py (Speech-to-text capabilities)
         - audio.py (Audio input/output handling)
         - storage.py (Local memory)
         - config.py (Configuration management)
         - logging_config.py (Logging setup)
       - .env (Environment variables)
       - setup.py (Python package setup)
   - Create necessary directories in user's home:
     - ~/.rin/logs (Logging directory)
     - ~/.rin/audio (Audio output storage)

2. Package Setup:
   - Use pip and venv for package management
   - Required dependencies:
     - click: For CLI interface
     - python-dotenv: For environment variable management
     - openai: For OpenAI API integration
     - google-cloud-texttospeech: For TTS functionality
     - whisper: For speech-to-text capabilities
     - sounddevice: For cross-platform audio I/O
     - pydub: For audio file processing
     - sqlite-utils: For simple SQLite operations
     - asyncio: For asynchronous processing
     - aiohttp: For async HTTP requests
     - numpy: For audio processing

3. Environment Configuration:
   - Store API keys and credentials in .env file
   - Required environment variables:
     - OPENAI_API_KEY: For OpenAI interaction
     - GOOGLE_APPLICATION_CREDENTIALS: Path to Google Cloud credentials file
     - TTS_ENGINE: Text-to-speech engine choice (google, coqui)
     - STT_ENGINE: Speech-to-text engine choice (whisper, google)
     - LOG_LEVEL: Logging verbosity
   - Never hardcode sensitive information in code files
   - Add .env to .gitignore to prevent committing secrets

4. Initialization Process:
   - Create a config module for centralized configuration management
   - Implement proper logging with separate loggers per module
   - Use proper error handling when initializing services
   - Use asynchronous initialization for non-blocking operations
   - Validate environment variables before using them
   - Separate core app logic from interface concerns
   - Use factory pattern for service implementations

5. Basic Setup Commands:
   - Use proper virtual environment creation and activation
   - Recommend proper pip commands for installation
   - Set up development mode installation with pip -e
   - Include setup.py with entry points for CLI commands
   - Support cross-platform installation

6. Code Organization:
   - Use a modular approach with separation of concerns
   - Create abstract base classes for service interfaces
   - Implement proper error handling and logging
   - Use asynchronous programming for responsive UX
   - Implement cross-platform audio handling
   - Create factory methods for component creation

7. Code Style:
   - Use consistent naming conventions (snake_case for Python)
   - Add proper docstrings for modules, classes and functions
   - Use type hints where appropriate
   - Create proper abstraction layers
   - Follow PEP 8 guidelines for Python code
```

</details>

### Implementation Examples

<details>
<summary>**Directory Structure & Setup Commands**</summary>

```bash
mkdir -p rin-cli/rin
cd rin-cli
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

pip install -U pip
pip install click python-dotenv openai google-cloud-texttospeech sqlite-utils \
  sounddevice numpy whisper pydub asyncio aiohttp 

# Create module files
touch rin/__init__.py rin/cli.py rin/core.py rin/llm.py rin/tts.py rin/stt.py 
touch rin/audio.py rin/storage.py rin/config.py rin/logging_config.py
touch setup.py

# Create data directories
mkdir -p ~/.rin/logs ~/.rin/audio
```

</details>

<details>
<summary>**.env File Setup**</summary>

```
# .env
OPENAI_API_KEY=your_openai_key
GOOGLE_APPLICATION_CREDENTIALS=/absolute/path/to/google-credentials.json
AUDIO_OUTPUT_DIR=~/.rin/audio
TTS_ENGINE=google  # Options: google, coqui (when implemented)
STT_ENGINE=whisper  # Options: whisper, google (when implemented)
LOG_LEVEL=INFO
```

</details>

<details>
<summary>**setup.py Configuration**</summary>

```python
from setuptools import setup, find_packages

setup(
    name='rin-cli',
    version='0.1.0',
    packages=find_packages(),
    install_requires=[
        'click',
        'openai',
        'python-dotenv',
        'google-cloud-texttospeech',
        'sounddevice',
        'numpy',
        'whisper',
        'pydub',
        'asyncio',
        'aiohttp',
        'sqlite-utils'
    ],
    entry_points='''
        [console_scripts]
        rin=rin.cli:cli
    ''',
)
```

</details>

## CLI Development Rule

This rule helps you build the CLI interface for the Rin V0 prototype using Click and asyncio.

<details>
<summary>**Click to see the complete CLI Development rule**</summary>

```
# Rin V0 CLI Development Rule
# This rule helps with implementing the CLI interface using Click and asyncio

# Define which files this rule applies to
*.py
rin/cli.py
rin/core.py
rin/commands/*.py

# Include setup rule for context
@file:.cursor/rules/Rin-v0-step1-setup.cursorignore

# Rule content below
When helping with the Rin V0 CLI implementation:

1. CLI Structure Guidelines:
   - Use Click for command line parsing and execution
   - Implement the following commands:
     - ask: For asking Rin a question via text
     - listen: For recording speech and responding
     - remember: For viewing past interactions
     - speak: For text-to-speech conversion
   - Keep the CLI entry point clean and modular
   - Use asyncio.run() to handle async operations
   - Add proper descriptions for each command
   - Create a separate core layer for business logic

2. Command Implementation:
   - Each command should have:
     - A clear description
     - Proper argument and option handling
     - Good error handling with try/except
     - Clear user feedback
     - Async support for non-blocking operations
   - For the 'ask' command:
     - Send query to LLM client
     - Display the response
     - Properly handle errors and timeouts
     - Store interaction in local storage
   - For the 'listen' command:
     - Record audio using sounddevice
     - Transcribe using Whisper STT
     - Process the transcribed query
     - Optionally play back the response
   - For the 'remember' command:
     - Retrieve past interactions from storage
     - Display them in a readable format
     - Support pagination if many records exist
   - For the 'speak' command:
     - Convert text to speech using TTS engine
     - Save audio to file in user directory
     - Play the audio through system speakers
     - Support voice/language options

3. Error Handling:
   - Use try/except blocks for error handling
   - Provide useful error messages
   - Check for missing API credentials
   - Validate command inputs
   - Handle audio device errors gracefully
   - Add proper logging and error reporting
   - Use custom exceptions for specific error cases

4. User Experience:
   - Use click.echo for output formatting
   - Include loading indicators for long operations
   - Format output for better readability
   - Set reasonable default values
   - Add help text and examples
   - Consider accessibility for visually impaired users
   - Support different output formats

5. Code Organization:
   - Separate core logic from CLI presentation layer
   - Use dependency injection for services
   - Keep functions focused and small
   - Use async/await for non-blocking operations
   - Initialize required services centrally
   - Use factory patterns for component creation
   - Support modular extension for future features

6. CLI Entry Point:
   - Use click.group() for command grouping
   - Use click.command() decorators for subcommands
   - Load environment variables early
   - Provide global help and version information
   - Handle keyboard interrupts gracefully
   - Set up logging early in the process
   - Initialize components using factory methods
```

</details>

### Implementation Example

<details>
<summary>**CLI Entry Point (rin/cli.py)**</summary>

```python
# rin/cli.py
import click
import asyncio
import logging
from rin.core import Assistant
from rin.audio import AudioHandler
from rin.logging_config import loggers

logger = loggers['core']
assistant = Assistant()

@click.group()
def cli():
    """Rin CLI - Personal Assistant Prototype"""
    pass

@cli.command()
@click.argument('query')
def ask(query):
    """Ask Rin a question"""
    try:
        response = asyncio.run(assistant.process_query(query))
        click.echo(f"Rin: {response['text']}")
    except Exception as e:
        click.echo(f"Error: {str(e)}")

@cli.command()
@click.option('--voice/--no-voice', default=True, help="Enable/disable voice response")
def listen(voice):
    """Listen for voice command and respond"""
    try:
        result = asyncio.run(assistant.listen_and_respond())
        click.echo(f"You said: {result.get('query', '')}")
        click.echo(f"Rin: {result.get('text', '')}")
        
        if voice and result.get('audio_path'):
            asyncio.run(AudioHandler.play_audio(result['audio_path']))
    except Exception as e:
        click.echo(f"Error: {str(e)}")

@cli.command()
def remember():
    """Show saved interactions"""
    try:
        interactions = asyncio.run(assistant.get_interaction_history())
        for i, item in enumerate(interactions):
            click.echo(f"[{i+1}] You: {item['query']}\nRin: {item['response']}\n")
    except Exception as e:
        click.echo(f"Error: {str(e)}")

@cli.command()
@click.argument('text')
def speak(text):
    """Convert text to speech"""
    try:
        path = asyncio.run(assistant.tts.synthesize(text))
        click.echo(f"Audio saved to {path}")
        asyncio.run(AudioHandler.play_audio(path))
    except Exception as e:
        click.echo(f"Error: {str(e)}")

if __name__ == '__main__':
    cli()
```

</details>

<details>
<summary>**Core Assistant Logic (rin/core.py)**</summary>

```python
# rin/core.py
import asyncio
import logging
from rin.llm import LLMInterface
from rin.tts import TTSInterface
from rin.stt import STTInterface
from rin.storage import Storage
from rin.config import TTS_ENGINE, STT_ENGINE
from rin.logging_config import loggers

logger = loggers['core']

class Assistant:
    """Core assistant logic, separate from UI/CLI concerns"""
    
    def __init__(self):
        self.storage = Storage()
        self.llm = LLMInterface.create()
        self.tts = TTSInterface.create(TTS_ENGINE)
        self.stt = STTInterface.create(STT_ENGINE)
        logger.info("Assistant initialized with TTS: %s, STT: %s", TTS_ENGINE, STT_ENGINE)
    
    async def process_query(self, query, respond_with_voice=False):
        """Process a text query and return response"""
        try:
            logger.info("Processing query: %s", query)
            response = await self.llm.generate_response(query)
            await self.storage.save_interaction(query, response)
            
            audio_path = None
            if respond_with_voice:
                audio_path = await self.tts.synthesize(response)
                
            return {
                "text": response,
                "audio_path": audio_path
            }
        except Exception as e:
            logger.error("Error processing query: %s", str(e), exc_info=True)
            return {
                "error": str(e),
                "text": "I encountered an error while processing your request."
            }
    
    async def listen_and_respond(self):
        """Record from microphone, convert to text, and respond"""
        try:
            logger.info("Listening for speech input")
            query = await self.stt.transcribe_from_mic()
            if not query:
                return {"error": "Could not understand audio"}
                
            return await self.process_query(query, respond_with_voice=True)
        except Exception as e:
            logger.error("Error in listen and respond: %s", str(e), exc_info=True)
            return {"error": str(e)}
    
    async def get_interaction_history(self, limit=10):
        """Retrieve conversation history"""
        return await self.storage.get_interactions(limit)
```

</details>

## Storage Implementation Rule

This rule helps you implement the async SQLite-based storage system for the Rin V0 prototype.

<details>
<summary>**Click to see the complete Storage Implementation rule**</summary>

```
# Rin V0 Storage Implementation Rule
# This rule helps with implementing the SQLite-based storage system with async support

# Define which files this rule applies to
*.py
rin/storage.py
rin/db/*.py
rin/models/*.py

# Include setup rule for context
@file:.cursor/rules/Rin-v0-step1-setup.cursorignore

# Rule content below
When helping with the Rin V0 storage implementation:

1. SQLite Setup:
   - Use Python's built-in sqlite3 module for database operations
   - Create a database in a user-specific location (~/.rin/ folder)
   - Make database operations non-blocking with asyncio
   - Run SQLite operations in executor to avoid blocking main thread
   - Initialize database and tables in the class constructor
   - Use connections and cursors properly
   - Use context managers or proper cleanup for connections

2. Database Schema:
   - Create an interactions table with:
     - id: Primary key, auto-increment
     - query: User's question text
     - response: Assistant's response text
     - timestamp: When the interaction occurred
   - Use appropriate data types for columns
   - Add indexes for frequently queried fields
   - Use TEXT DEFAULT CURRENT_TIMESTAMP for timestamps in SQLite
   - Plan schema for future extensions

3. Async Storage API Design:
   - Implement a Storage class with the following methods:
     - __init__(): Initialize the database connection
     - _init_db(): Create necessary tables and indexes (sync)
     - async save_interaction(query, response): Store a new interaction
     - async get_interactions(limit): Retrieve recent interactions
   - Use parameterized queries for security
   - Implement proper error handling with exceptions
   - Implement private synchronous methods to run in executor
   - Wrap synchronous calls in loop.run_in_executor()

4. Error Handling and Logging:
   - Use try/except blocks for database operations
   - Close connections properly
   - Add rollback for transactions
   - Use specific exception types for different errors
   - Provide helpful error messages
   - Log errors, warnings, and info messages
   - Include error context in logs
   - Return meaningful error responses

5. Data Management:
   - Implement data cleanup for old records
   - Use transactions for multi-statement operations
   - Add proper validation before storing data
   - Return data as dictionaries for easier use
   - Consider data migration strategy for future schema changes
   - Support pagination for large result sets
   - Add support for searching and filtering

6. Performance Considerations:
   - Use proper indexing for query performance
   - Keep connections open when appropriate
   - Close connections when done
   - Use executemany for batch operations
   - Run database operations in separate thread via executor
   - Structure code to minimize blocking operations
   - Add connection timeouts
```

</details>

### Implementation Example

<details>
<summary>**Storage Module (rin/storage.py)**</summary>

```python
# rin/storage.py
import sqlite3
import asyncio
import logging
from pathlib import Path
from rin.config import RIN_DIR
from rin.logging_config import loggers

logger = loggers['storage']

class Storage:
    """Database storage with async support"""
    
    def __init__(self):
        self.path = RIN_DIR / "rin.db"
        # Initialize synchronously
        self._init_db()
        logger.info(f"Storage initialized at {self.path}")
    
    def _init_db(self):
        """Initialize database schema"""
        conn = sqlite3.connect(self.path)
        conn.execute('''CREATE TABLE IF NOT EXISTS interactions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            query TEXT,
            response TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )''')
        conn.commit()
        conn.close()
    
    async def save_interaction(self, query, response):
        """Save interaction to database asynchronously"""
        try:
            logger.debug(f"Saving interaction: Q: {query[:50]}... R: {response[:50]}...")
            
            # Run in executor to avoid blocking
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(
                None,
                self._save_interaction_sync,
                query,
                response
            )
            return True
        except Exception as e:
            logger.error(f"Error saving interaction: {str(e)}", exc_info=True)
            return False
    
    def _save_interaction_sync(self, query, response):
        """Synchronous database save (to be run in executor)"""
        conn = sqlite3.connect(self.path)
        conn.execute(
            "INSERT INTO interactions (query, response) VALUES (?, ?)", 
            (query, response)
        )
        conn.commit()
        conn.close()
    
    async def get_interactions(self, limit=10):
        """Get recent interactions asynchronously"""
        try:
            logger.debug(f"Retrieving {limit} recent interactions")
            
            # Run in executor to avoid blocking
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self._get_interactions_sync,
                limit
            )
            return result
        except Exception as e:
            logger.error(f"Error getting interactions: {str(e)}", exc_info=True)
            return []
    
    def _get_interactions_sync(self, limit):
        """Synchronous database query (to be run in executor)"""
        conn = sqlite3.connect(self.path)
        cursor = conn.cursor()
        cursor.execute(
            "SELECT query, response FROM interactions ORDER BY timestamp DESC LIMIT ?", 
            (limit,)
        )
        result = [dict(query=row[0], response=row[1]) for row in cursor.fetchall()]
        conn.close()
        return result
    
    async def cleanup_old_interactions(self, days=30):
        """Remove interactions older than specified days"""
        try:
            logger.info(f"Cleaning up interactions older than {days} days")
            loop = asyncio.get_event_loop()
            deleted_count = await loop.run_in_executor(
                None,
                self._cleanup_old_interactions_sync,
                days
            )
            logger.info(f"Deleted {deleted_count} old interactions")
            return deleted_count
        except Exception as e:
            logger.error(f"Error cleaning up old interactions: {str(e)}", exc_info=True)
            return 0
    
    def _cleanup_old_interactions_sync(self, days):
        """Synchronous database cleanup (to be run in executor)"""
        conn = sqlite3.connect(self.path)
        try:
            cursor = conn.cursor()
            cursor.execute(
                "DELETE FROM interactions WHERE datetime(timestamp) < datetime('now', ?)",
                (f'-{days} days',)
            )
            conn.commit()
            deleted_count = cursor.rowcount
            return deleted_count
        except sqlite3.Error as e:
            conn.rollback()
            raise e
        finally:
            conn.close()
```

</details>

## API Integration Rule

This rule helps you implement API integrations for the Rin V0 prototype, focusing on OpenAI LLM, TTS, and STT services with async support.

<details>
<summary>**Click to see the complete API Integration rule**</summary>

```
# Rin V0 API Integration Rule
# This rule helps with integrating external APIs with async support

# Define which files this rule applies to
*.py
rin/llm.py
rin/tts.py
rin/stt.py
rin/audio.py

# Include setup rule for context
@file:.cursor/rules/Rin-v0-step1-setup.cursorignore

# Rule content below
When helping with the Rin V0 API integrations:

1. LLM Integration (OpenAI):
   - Use the official openai Python package
   - Create an abstract LLMInterface class for future model flexibility
   - Implement factory pattern via static create() method
   - Set up the API key from environment variables or config
   - Use the ChatCompletion API for conversations
   - Set reasonable model (gpt-4 or gpt-3.5-turbo) from config
   - Create a consistent system prompt for Rin
   - Make API calls asynchronous with asyncio.run_in_executor
   - Extract the message content from responses
   - Set appropriate parameters (temperature, max_tokens)
   - Handle API rate limits and implement retries
   - Use proper error handling and logging

2. Text-to-Speech (TTS) Integration:
   - Create an abstract TTSInterface class with factory pattern
   - Implement Google Cloud TTS as primary engine
   - Plan for Coqui TTS as offline alternative
   - Use the google-cloud-texttospeech package
   - Set up authentication using credentials file path
   - Choose appropriate voice settings via configuration
   - Support multiple languages and voice options
   - Implement audio format options (MP3, WAV)
   - Make API calls asynchronous with asyncio.run_in_executor
   - Save audio output to configurable directory
   - Generate unique filenames for audio files
   - Implement proper error handling and logging

3. Speech-to-Text (STT) Integration:
   - Create an abstract STTInterface class with factory pattern
   - Implement Whisper for local speech recognition
   - Plan for Google Speech-to-Text as alternative
   - Use OpenAI's whisper library for transcription
   - Load models asynchronously to avoid blocking startup
   - Support different model sizes via configuration
   - Implement transcribe_audio() method for file input
   - Implement transcribe_from_mic() for microphone input
   - Handle different languages and accents
   - Make API calls asynchronous with asyncio.run_in_executor
   - Implement proper error handling and logging

4. Audio Management:
   - Create AudioHandler class for common audio operations
   - Use sounddevice for cross-platform audio recording
   - Use pydub for cross-platform audio playback
   - Support configurable recording parameters
   - Implement audio file format conversion if needed
   - Create asynchronous methods for recording and playback
   - Handle audio device errors gracefully
   - Support different sample rates and audio formats
   - Implement timeouts and error recovery
   - Use proper error handling and logging

5. API Error Handling:
   - Create clear error hierarchy with specific exceptions
   - Implement retries with exponential backoff
   - Handle network errors and timeouts
   - Process service-specific errors appropriately
   - Log errors with context for debugging
   - Provide clear error messages to users
   - Handle authentication errors
   - Validate inputs before sending to APIs
   - Implement graceful degradation for offline use

6. API Security and Architecture:
   - Never hardcode API keys in source code
   - Use environment variables or secure configuration
   - Set appropriate permissions for credential files
   - Validate and sanitize user input
   - Use HTTPS for all API connections
   - Follow principle of least privilege
   - Create abstraction layers via abstract base classes
   - Use dependency injection for testing
   - Make API services easily swappable
   - Implement caching where appropriate
```

</details>

### Implementation Examples

<details>
<summary>**LLM Service (rin/llm.py)**</summary>

```python
# rin/llm.py
import os
import openai
import asyncio
import logging
from abc import ABC, abstractmethod
from rin.config import OPENAI_API_KEY, LLM_MODEL, SYSTEM_PROMPT
from rin.logging_config import loggers

logger = loggers['llm']

class LLMInterface(ABC):
    """Abstract base class for LLM providers"""
    
    @staticmethod
    def create(provider="openai"):
        """Factory method to create appropriate LLM client"""
        if provider == "openai":
            return OpenAIClient()
        # Add more providers here as needed
        else:
            raise ValueError(f"Unknown LLM provider: {provider}")
    
    @abstractmethod
    async def generate_response(self, query):
        """Generate a response to the given query"""
        pass

class OpenAIClient(LLMInterface):
    def __init__(self):
        openai.api_key = OPENAI_API_KEY
        self.model = LLM_MODEL
        logger.info(f"Initialized OpenAI client with model {self.model}")
    
    async def generate_response(self, query):
        """Asynchronously generate a response using OpenAI"""
        try:
            logger.info(f"Generating response for query using {self.model}")
            
            # Run in executor to avoid blocking
            loop = asyncio.get_event_loop()
            response = await loop.run_in_executor(
                None,
                lambda: openai.ChatCompletion.create(
                    model=self.model,
                    messages=[
                        {"role": "system", "content": SYSTEM_PROMPT},
                        {"role": "user", "content": query}
                    ],
                    temperature=0.7,
                    max_tokens=500
                )
            )
            
            content = response.choices[0].message.content
            logger.debug(f"Generated response: {content[:50]}...")
            return content
        except Exception as e:
            logger.error(f"Error generating response: {str(e)}", exc_info=True)
            raise
```

</details>

<details>
<summary>**Text-to-Speech Service (rin/tts.py)**</summary>

```python
# rin/tts.py
import os
import time
import asyncio
import logging
from abc import ABC, abstractmethod
from pathlib import Path
from google.cloud import texttospeech
from rin.config import AUDIO_DIR, GOOGLE_CREDENTIALS
from rin.logging_config import loggers

logger = loggers['tts']

class TTSInterface(ABC):
    """Abstract base class for TTS engines"""
    
    @staticmethod
    def create(engine="google"):
        """Factory method to create appropriate TTS engine"""
        if engine == "google":
            return GoogleTTS()
        elif engine == "coqui":
            # Placeholder for future implementation
            raise NotImplementedError("Coqui TTS not yet implemented")
        else:
            raise ValueError(f"Unknown TTS engine: {engine}")
    
    @abstractmethod
    async def synthesize(self, text):
        """Convert text to speech and return audio file path"""
        pass

class GoogleTTS(TTSInterface):
    def __init__(self):
        os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = GOOGLE_CREDENTIALS
        self.client = texttospeech.TextToSpeechClient()
        logger.info("Initialized Google TTS client")
    
    async def synthesize(self, text):
        """Asynchronously synthesize text to speech using Google Cloud"""
        try:
            logger.info(f"Synthesizing text: {text[:50]}...")
            
            # Run in executor to avoid blocking
            loop = asyncio.get_event_loop()
            response = await loop.run_in_executor(
                None,
                lambda: self._synthesize_sync(text)
            )
            
            # Generate unique filename
            timestamp = int(time.time())
            output_file = AUDIO_DIR / f"rin_tts_{timestamp}.mp3"
            
            # Save audio content
            with open(output_file, "wb") as out:
                out.write(response.audio_content)
                
            logger.info(f"Audio saved to {output_file}")
            return str(output_file)
        except Exception as e:
            logger.error(f"Error synthesizing speech: {str(e)}", exc_info=True)
            raise
    
    def _synthesize_sync(self, text):
        """Synchronous Google TTS call (to be run in executor)"""
        synthesis_input = texttospeech.SynthesisInput(text=text)
        voice = texttospeech.VoiceSelectionParams(
            language_code="en-US", 
            ssml_gender=texttospeech.SsmlVoiceGender.NEUTRAL
        )
        audio_config = texttospeech.AudioConfig(
            audio_encoding=texttospeech.AudioEncoding.MP3
        )
        
        return self.client.synthesize_speech(
            input=synthesis_input, 
            voice=voice, 
            audio_config=audio_config
        )
```

</details>

<details>
<summary>**Speech-to-Text Service (rin/stt.py)**</summary>

```python
# rin/stt.py
import os
import whisper
import asyncio
import logging
from abc import ABC, abstractmethod
from rin.audio import AudioHandler
from rin.config import WHISPER_MODEL
from rin.logging_config import loggers

logger = loggers['stt']

class STTInterface(ABC):
    """Abstract base class for STT engines"""
    
    @staticmethod
    def create(engine="whisper"):
        """Factory method to create appropriate STT engine"""
        if engine == "whisper":
            return WhisperSTT()
        elif engine == "google":
            # Placeholder for future implementation
            raise NotImplementedError("Google STT not yet implemented")
        else:
            raise ValueError(f"Unknown STT engine: {engine}")
    
    @abstractmethod
    async def transcribe_audio(self, audio_file):
        """Transcribe audio file to text"""
        pass
        
    @abstractmethod
    async def transcribe_from_mic(self, duration=5):
        """Record from microphone and transcribe"""
        pass

class WhisperSTT(STTInterface):
    def __init__(self):
        logger.info(f"Loading Whisper model: {WHISPER_MODEL}")
        # Load model in a separate thread to avoid blocking
        loop = asyncio.get_event_loop()
        self.model = loop.run_in_executor(None, lambda: whisper.load_model(WHISPER_MODEL))
        logger.info("Whisper STT initialized")
    
    async def transcribe_audio(self, audio_file):
        """Transcribe audio file using Whisper"""
        try:
            logger.info(f"Transcribing audio file: {audio_file}")
            model = await self.model  # Ensure model is loaded
            
            # Run transcription in executor to avoid blocking
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                lambda: model.transcribe(audio_file)
            )
            
            text = result["text"].strip()
            logger.info(f"Transcription: {text}")
            return text
        except Exception as e:
            logger.error(f"Error transcribing audio: {str(e)}", exc_info=True)
            return ""
    
    async def transcribe_from_mic(self, duration=5):
        """Record from microphone and transcribe"""
        try:
            audio_file = await AudioHandler.record_audio(duration=duration)
            return await self.transcribe_audio(audio_file)
        except Exception as e:
            logger.error(f"Error in transcribe_from_mic: {str(e)}", exc_info=True)
            return ""
```

</details>

<details>
<summary>**Audio Handler (rin/audio.py)**</summary>

```python
# rin/audio.py
import sounddevice as sd
import numpy as np
import wave
import logging
import time
from pathlib import Path
import tempfile
from pydub import AudioSegment
from pydub.playback import play
from rin.config import AUDIO_DIR
from rin.logging_config import loggers

logger = loggers['audio']

class AudioHandler:
    """Cross-platform audio recording and playback"""
    
    @staticmethod
    async def record_audio(duration=5, sample_rate=16000):
        """Record audio from microphone for specified duration"""
        try:
            logger.info(f"Recording {duration}s of audio at {sample_rate}Hz")
            recording = sd.rec(
                int(duration * sample_rate),
                samplerate=sample_rate,
                channels=1,
                dtype='int16'
            )
            sd.wait()  # Wait until recording is finished
            
            # Save to temp file
            temp_file = Path(tempfile.gettempdir()) / f"rin_recording_{int(time.time())}.wav"
            with wave.open(str(temp_file), 'wb') as wf:
                wf.setnchannels(1)
                wf.setsampwidth(2)  # 16-bit
                wf.setframerate(sample_rate)
                wf.writeframes(recording.tobytes())
            
            logger.info(f"Recording saved to {temp_file}")
            return str(temp_file)
        except Exception as e:
            logger.error(f"Error recording audio: {str(e)}", exc_info=True)
            raise
    
    @staticmethod
    async def play_audio(file_path):
        """Play audio file using pydub (cross-platform)"""
        try:
            logger.info(f"Playing audio: {file_path}")
            sound = AudioSegment.from_file(file_path)
            play(sound)
            return True
        except Exception as e:
            logger.error(f"Error playing audio: {str(e)}", exc_info=True)
            return False
```

</details>

## Testing and Debugging Rule

This rule helps you test and debug the Rin V0 prototype with async support, STT/TTS features, and better error handling.

<details>
<summary>**Click to see the complete Testing and Debugging rule**</summary>

```
# Rin V0 Testing and Debugging Rule
# This rule helps with testing and debugging the CLI application

# Define which files this rule applies to
*.py
tests/*.py
test_*.py
conftest.py

# Include setup rule for context
@file:.cursor/rules/Rin-v0-step1-setup.cursorignore

# Rule content below
When helping with testing and debugging the Rin V0 CLI:

1. Manual Testing Approach:
   - Test each command individually with various inputs
   - Test async functions using asyncio.run() in scripts
   - Create separate test for each major component:
     - LLM interaction
     - TTS conversion
     - STT transcription
     - Audio recording/playback
     - Storage operations
   - Test happy paths and error cases
   - Test with different input types and edge cases
   - Test with and without internet connectivity
   - Verify logging is working correctly
   - Test cross-platform issues on different OSes

2. Common Issues to Check:
   - Missing environment variables or configuration
   - Database connection issues
   - API authentication problems
   - Path and permission issues for file operations
   - Command syntax or usage problems
   - Error handling gaps
   - Dependency installation issues
   - Audio device access problems
   - Async event loop issues
   - Microphone permissions and setup
   - File format compatibility issues

3. Debugging Asynchronous Code:
   - Use proper logging with context in async functions
   - Add try/except with informative error messages
   - Log entry and exit points of async functions
   - Test async components in isolation
   - Check for event loop issues (running, closed, etc.)
   - Handle task cancellation properly
   - Watch for blocking operations in async code
   - Use asyncio.create_task() for truly parallel work
   - Test timeouts and error handling
   - Implement graceful degradation for network issues

4. Audio and Speech Testing:
   - Create test audio files for STT component
   - Test microphone access cross-platform
   - Verify audio playback works in different environments
   - Test with different audio formats
   - Check for sample rate issues
   - Test with background noise to assess STT robustness
   - Verify TTS output quality
   - Test with different languages if supported
   - Check for audio device errors
   - Implement fallbacks for audio issues

5. Environment Setup Validation:
   - Confirm Python version is compatible (3.9+)
   - Verify all dependencies are installed
   - Check that virtual environment is activated
   - Validate API keys and credentials
   - Verify paths in config are correct and accessible
   - Check file system permissions for logs and audio
   - Test network connectivity for API calls
   - Verify audio devices are accessible
   - Confirm directory structure exists
   - Test with minimal environment settings

6. Test Scripts and Documentation:
   - Create simple test scripts for common operations
   - Implement pytest fixtures for common test setup
   - Add tests for async functions using pytest-asyncio
   - Create mock classes for external services
   - Document common errors and solutions
   - Include troubleshooting steps in README
   - Add example commands with expected output
   - Create sample configuration files
   - Document platform-specific setup steps
   - Add tests for factory methods and dependency injection
```

</details>

### Implementation Examples

<details>
<summary>**Manual Testing Script (tests/test_manual.py)**</summary>

```python
#!/usr/bin/env python3
# tests/test_manual.py
import os
import asyncio
import tempfile
from pathlib import Path

# Initialize test environment
test_env = {
    "OPENAI_API_KEY": os.environ.get("OPENAI_API_KEY"),
    "GOOGLE_APPLICATION_CREDENTIALS": os.environ.get("GOOGLE_APPLICATION_CREDENTIALS"),
    "TTS_ENGINE": "google",
    "STT_ENGINE": "whisper",
    "WHISPER_MODEL": "base",
    "LOG_LEVEL": "DEBUG"
}

# Import after setting environment
from rin.core import Assistant
from rin.llm import LLMInterface
from rin.tts import TTSInterface
from rin.stt import STTInterface
from rin.storage import Storage
from rin.audio import AudioHandler
from rin.config import AUDIO_DIR

async def test_llm():
    """Test LLM functionality"""
    print("\n--- Testing LLM ---")
    try:
        llm = LLMInterface.create()
        query = "What is the capital of France?"
        print(f"Query: {query}")
        response = await llm.generate_response(query)
        print(f"Response: {response}")
        assert "Paris" in response, "Expected 'Paris' in response"
        print("✅ LLM test passed")
        return True
    except Exception as e:
        print(f"❌ LLM test failed: {str(e)}")
        return False

async def test_tts():
    """Test TTS functionality"""
    print("\n--- Testing TTS ---")
    try:
        tts = TTSInterface.create()
        text = "This is a test of the text to speech system."
        print(f"Text: {text}")
        audio_path = await tts.synthesize(text)
        print(f"Audio saved to: {audio_path}")
        assert os.path.exists(audio_path), "Audio file was not created"
        print("✅ TTS test passed")
        return audio_path
    except Exception as e:
        print(f"❌ TTS test failed: {str(e)}")
        return None

async def test_audio_playback(audio_path):
    """Test audio playback"""
    print("\n--- Testing Audio Playback ---")
    if not audio_path:
        print("❌ Skipping audio playback test (no audio file)")
        return False
    
    try:
        print(f"Playing audio file: {audio_path}")
        result = await AudioHandler.play_audio(audio_path)
        assert result, "Audio playback failed"
        print("✅ Audio playback test passed")
        return True
    except Exception as e:
        print(f"❌ Audio playback test failed: {str(e)}")
        return False

async def test_storage():
    """Test storage operations"""
    print("\n--- Testing Storage ---")
    try:
        # Use temp directory for testing
        with tempfile.TemporaryDirectory() as temp_dir:
            # Set RIN_DIR to temp directory for test
            import rin.config
            original_dir = rin.config.RIN_DIR
            rin.config.RIN_DIR = Path(temp_dir)
            
            # Create storage
            storage = Storage()
            
            # Test saving
            query = "Test query"
            response = "Test response"
            print(f"Saving interaction: Q: {query}, R: {response}")
            save_result = await storage.save_interaction(query, response)
            assert save_result, "Failed to save interaction"
            
            # Test retrieval
            interactions = await storage.get_interactions()
            print(f"Retrieved {len(interactions)} interactions")
            assert len(interactions) == 1, "Expected 1 interaction"
            assert interactions[0]["query"] == query, "Query doesn't match"
            assert interactions[0]["response"] == response, "Response doesn't match"
            
            # Restore config
            rin.config.RIN_DIR = original_dir
            
            print("✅ Storage test passed")
            return True
    except Exception as e:
        print(f"❌ Storage test failed: {str(e)}")
        return False

async def test_core_assistant():
    """Test the core Assistant class"""
    print("\n--- Testing Core Assistant ---")
    try:
        # Initialize assistant
        assistant = Assistant()
        
        # Test processing a query
        query = "What's the meaning of life?"
        print(f"Processing query: {query}")
        result = await assistant.process_query(query)
        
        # Verify response
        assert "text" in result, "Response missing text field"
        print(f"Response: {result['text'][:50]}...")
        
        print("✅ Assistant test passed")
        return True
    except Exception as e:
        print(f"❌ Assistant test failed: {str(e)}")
        return False

async def main():
    """Run all tests"""
    print("Running Rin CLI tests...\n")
    
    # Keep track of passed/failed tests
    passed = 0
    failed = 0
    
    # Test LLM
    if await test_llm():
        passed += 1
    else:
        failed += 1
    
    # Test TTS
    audio_path = await test_tts()
    if audio_path:
        passed += 1
    else:
        failed += 1
    
    # Test audio playback
    if await test_audio_playback(audio_path):
        passed += 1
    else:
        failed += 1
    
    # Test storage
    if await test_storage():
        passed += 1
    else:
        failed += 1
    
    # Test core assistant
    if await test_core_assistant():
        passed += 1
    else:
        failed += 1
    
    # Print summary
    print(f"\nTest summary: {passed} passed, {failed} failed")
    return 1 if failed > 0 else 0

if __name__ == "__main__":
    exit_code = asyncio.run(main())
    exit(exit_code)
```

</details>

<details>
<summary>**Pytest Example (tests/test_async.py)**</summary>

```python
# tests/test_async.py
import pytest
import asyncio
import os
import tempfile
from pathlib import Path
from unittest.mock import patch, MagicMock

# Import the modules to test
from rin.storage import Storage
from rin.llm import LLMInterface, OpenAIClient
from rin.config import RIN_DIR

# Async fixture for pytest
@pytest.fixture
def event_loop():
    """Create an instance of the default event loop for each test case."""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def temp_rin_dir():
    """Create a temporary directory for testing"""
    with tempfile.TemporaryDirectory() as temp_dir:
        # Patch RIN_DIR to use temp directory
        with patch('rin.config.RIN_DIR', Path(temp_dir)):
            # Create subdirectories
            Path(temp_dir, "logs").mkdir(exist_ok=True)
            Path(temp_dir, "audio").mkdir(exist_ok=True)
            yield Path(temp_dir)

@pytest.mark.asyncio
async def test_storage_save_and_retrieve(temp_rin_dir):
    """Test async storage operations"""
    # Create storage instance
    storage = Storage()
    
    # Test data
    test_query = "What is the weather today?"
    test_response = "I don't have real-time weather data."
    
    # Save interaction
    result = await storage.save_interaction(test_query, test_response)
    assert result is True, "Failed to save interaction"
    
    # Retrieve interactions
    interactions = await storage.get_interactions()
    assert len(interactions) == 1, "Expected 1 interaction"
    assert interactions[0]["query"] == test_query, "Query doesn't match"
    assert interactions[0]["response"] == test_response, "Response doesn't match"

@pytest.mark.asyncio
async def test_llm_with_mock():
    """Test LLM with mocked response"""
    # Mock the OpenAI API call
    mock_response = MagicMock()
    mock_response.choices = [MagicMock()]
    mock_response.choices[0].message.content = "This is a mocked response"
    
    # Create patched client
    with patch('openai.ChatCompletion.create', return_value=mock_response):
        llm = OpenAIClient()
        response = await llm.generate_response("Test query")
        
        assert response == "This is a mocked response", "Response doesn't match expected mock"

@pytest.mark.asyncio
async def test_factory_pattern():
    """Test factory pattern for LLM creation"""
    # Mock the OpenAI API calls
    with patch('rin.llm.OpenAIClient') as mock_openai:
        # Set up mock return value
        instance = MagicMock()
        mock_openai.return_value = instance
        
        # Test factory method
        llm = LLMInterface.create()
        
        # Verify the correct class was instantiated
        mock_openai.assert_called_once()
        assert llm == instance, "Factory didn't return expected instance"
        
        # Test with invalid provider
        with pytest.raises(ValueError):
            LLMInterface.create("invalid_provider")
```

</details>

## How to Use These Rules

1. **Copy the rule content**: Click on the dropdown for the specific rule you need
2. **Create a file**: In your project, create a file at <code>.cursor/rules/Rin-v0-step1-[component].cursorignore</code>
3. **Paste the rule**: Paste the copied content into the file
4. **Start developing**: As you work on the component, Cursor will provide guidance based on the rule

You can also chain rules together using the <code>@file</code> reference system:

```
# In other rules, include the setup rule for context
@file:.cursor/rules/Rin-v0-step1-setup.cursorignore

# Additional rule content below
```

These rules are designed to work together to guide you through implementing the enhanced version of Rin V0 with async support, proper error handling, and a more modular architecture that will make expanding to V1 features much easier.
---
title: "V0 Step 2: Voice & Interaction Rules"
navOrder: 2
---

# Rin V0 Step 2: Voice & Interaction Rules

This page contains all the Cursor rules you need to implement the Voice & Interaction features for Rin V0 as outlined in the [Step 2: Voice and Interaction](/v0/voice-and-interaction) guide.

## Setting Up Cursor Rules

To use these rules in your project, follow these steps:

1. Create a rules directory in your project:
```bash
mkdir -p .cursor/rules
```

2. For each rule below, create a corresponding <code>.cursorignore</code> file in the <code>.cursor/rules</code> directory with the rule content.

For example, to set up the STT Implementation rule:
```bash
# Copy the STT Implementation rule content
# Create the rule file
touch .cursor/rules/Rin-v0-step2-stt.cursorignore
# Paste the rule content into the file
```

3. You can now use these rules in Cursor to guide your development process. Cursor will automatically apply these rules when you work on relevant files.

## STT Implementation Rule

This rule helps you implement speech-to-text functionality using Google Cloud Speech.

<details>
<summary>**Click to see the complete STT Implementation rule**</summary>

```
# Rin V0 STT Implementation Rule
# This rule helps with implementing the Speech-to-Text functionality using Google Cloud Speech

# Define which files this rule applies to
*.js
src/speech.js
src/voice/*.js
src/services/stt-service.js

# Rule content below
When helping with the Rin V0 Speech-to-Text implementation:

1. Google Cloud Speech Integration:
   - Use @google-cloud/speech npm package
   - Configure with proper authentication
   - Setup continuous streaming recognition
   - Handle audio capture using node-record-lpcm16
   - Support interruption of listening sessions
   - Implement error handling for speech recognition
   - Set appropriate language code (default to en-US)
   - Configure proper audio encoding for microphone input

2. Audio Capture Setup:
   - Use node-record-lpcm16 for microphone access
   - Set appropriate sample rate (16000 Hz)
   - Configure audio threshold for noise reduction
   - Implement proper audio stream piping to the Speech API
   - Handle recording errors and device unavailability
   - Support graceful shutdown of recording streams
   - Document audio hardware requirements

3. Speech Recognition Configuration:
   - Set LINEAR16 encoding for best compatibility
   - Configure sampleRateHertz to match recording settings
   - Set appropriate languageCode (en-US default)
   - Configure interimResults for real-time feedback
   - Set reasonable silence threshold 
   - Implement single utterance mode for command-based interactions
   - Configure alternatives for improved recognition accuracy

4. Stream Processing:
   - Implement proper event handlers for recognition stream
   - Process recognition results correctly
   - Extract transcript from alternatives
   - Handle end-of-speech detection
   - Support cancellation of in-progress recognition
   - Manage connection timeouts and reconnects
   - Log recognition confidence scores for debugging

5. Error Handling:
   - Handle network connectivity issues
   - Manage API authentication errors
   - Implement retry logic for failed recognitions
   - Provide user feedback for recognition failures
   - Log detailed error information for debugging
   - Handle microphone access issues gracefully
   - Support fallback to text input when speech fails

6. Implementation Structure:
   - Create a clean API for speech recognition
   - Support callback-based result handling
   - Isolate Google Cloud Speech specifics behind abstraction
   - Document limitations and requirements
   - Implement proper resource cleanup
   - Provide example usage patterns
   - Support both one-shot and continuous listening modes
```

</details>

### Implementation Examples

<details>
<summary>**Example STT Setup**</summary>

```javascript
// src/speech.js
const record = require('node-record-lpcm16');
const speech = require('@google-cloud/speech');

// Initialize speech client with authentication
const speechClient = new speech.SpeechClient({
  keyFilename: process.env.GOOGLE_CLOUD_CREDENTIALS
});

/**
 * Start listening for speech and convert to text
 * @param {Function} callback - Function to call with transcribed text
 * @param {Object} options - Configuration options
 */
function startListening(callback, options = {}) {
  // Set default options
  const encoding = options.encoding || 'LINEAR16';
  const sampleRateHertz = options.sampleRateHertz || 16000;
  const languageCode = options.languageCode || 'en-US';
  const interimResults = options.interimResults || false;
  const singleUtterance = options.singleUtterance || true;

  // Configure recognition request
  const request = {
    config: {
      encoding: encoding,
      sampleRateHertz: sampleRateHertz,
      languageCode: languageCode,
      enableAutomaticPunctuation: true,
      model: 'command_and_search',
      useEnhanced: true,
      maxAlternatives: 1
    },
    interimResults: interimResults,
    singleUtterance: singleUtterance
  };

  // Create a recognize stream
  let recognizeStream = null;
  let isListening = false;
  let recordingStream = null;

  // Function to start the recognition
  function startRecognitionStream() {
    recognizeStream = speechClient
      .streamingRecognize(request)
      .on('error', (error) => {
        console.error('Error in speech recognition:', error);
        if (error.code === 14 || error.code === 'UNAVAILABLE') {
          // Handle network errors with reconnection
          console.log('Network error, attempting to reconnect...');
          restartRecognitionStream();
        }
      })
      .on('data', (data) => {
        if (data.results[0] && data.results[0].alternatives[0]) {
          const transcript = data.results[0].alternatives[0].transcript;
          const isFinal = data.results[0].isFinal;
          
          if (isFinal) {
            console.log(`Recognized: ${transcript}`);
            callback(transcript);
            
            // If in single utterance mode, stop listening after processing
            if (singleUtterance) {
              stopListening();
            }
          }
        }
      })
      .on('end', () => {
        console.log('Recognition stream ended');
      });
  }

  // Function to restart recognition if needed
  function restartRecognitionStream() {
    if (recognizeStream) {
      recognizeStream.removeAllListeners();
      recognizeStream.end();
      recognizeStream = null;
    }
    
    if (isListening) {
      startRecognitionStream();
    }
  }

  // Start recording and send the microphone input to the Speech API
  console.log('Listening, press Ctrl+C to stop.');
  isListening = true;
  startRecognitionStream();
  
  recordingStream = record
    .start({
      sampleRateHertz: sampleRateHertz,
      threshold: 0,
      recordProgram: 'rec', // Use SoX recording
      silence: '1.0', // Silence detection in seconds
    })
    .on('error', (err) => {
      console.error('Recording error:', err);
      stopListening();
    });
  
  recordingStream.pipe(recognizeStream);

  // Function to stop listening
  function stopListening() {
    if (isListening) {
      isListening = false;
      
      if (recordingStream) {
        recordingStream.stop();
        recordingStream = null;
      }
      
      if (recognizeStream) {
        recognizeStream.end();
        recognizeStream = null;
      }
      
      console.log('Stopped listening');
    }
  }

  // Return control function to stop listening
  return {
    stop: stopListening
  };
}

module.exports = { startListening };
```

</details>

## Wake Word Detection Rule

This rule helps you implement wake word detection using Snowboy.

<details>
<summary>**Click to see the complete Wake Word Detection rule**</summary>

```
# Rin V0 Wake Word Detection Rule
# This rule helps with implementing wake word detection using Snowboy

# Define which files this rule applies to
*.js
src/wake-word.js
src/voice/*.js
src/services/wake-word-service.js

# Rule content below
When helping with the Rin V0 Wake Word Detection implementation:

1. Snowboy Integration:
   - Use snowboy package for lightweight wake word detection
   - Set up proper detection models and resources
   - Configure detection sensitivity appropriately
   - Handle model loading and initialization
   - Implement hot word detection event handling
   - Use resource path resolution for packaged applications
   - Support custom wake word models when available

2. Audio Capture Setup:
   - Use node-record-lpcm16 for microphone access
   - Configure appropriate sample rate for detection
   - Set audio threshold for background noise handling
   - Implement proper audio stream piping to detector
   - Handle recording errors gracefully
   - Support continuous listening with low resource usage
   - Ensure compatibility with STT module

3. Wake Word Model Management:
   - Support default "Rin" wake word model
   - Provide a path to use custom trained models
   - Document model format and training process
   - Handle model loading errors appropriately
   - Set proper sensitivity for reliable detection
   - Support multiple hotwords if needed
   - Allow hotword customization in the future

4. Detection Configuration:
   - Set reasonable sensitivity (0.5 default)
   - Configure audio gain for varying microphone setups
   - Set appropriate resource path resolution
   - Support detection callback for event-based architecture
   - Enable graceful detection restart
   - Implement debug mode for diagnostics
   - Document minimum hardware requirements

5. Error Handling:
   - Handle microphone access errors
   - Manage model loading failures
   - Log detailed error information
   - Implement fallback mechanisms
   - Support retry on transient failures
   - Gracefully degrade functionality when needed
   - Provide clear user feedback for setup issues

6. Integration with Speech Recognition:
   - Design smooth handoff to STT module
   - Support pipeline architecture for wake word → STT → processing
   - Avoid resource conflicts between modules
   - Implement proper resource cleanup
   - Document API usage patterns
   - Support both standalone and integrated usage
   - Enable activation/deactivation during runtime
```

</details>

### Implementation Examples

<details>
<summary>**Example Wake Word Setup**</summary>

```javascript
// src/wake-word.js
const record = require('node-record-lpcm16');
const path = require('path');
const fs = require('fs');
const { Detector, Models } = require('snowboy');

// Ensure models directory exists
const modelsDir = path.join(__dirname, '../models');
if (!fs.existsSync(modelsDir)) {
  fs.mkdirSync(modelsDir, { recursive: true });
}

// Path to the wake word model
// In production, you would provide a pre-trained model
const defaultWakeWordModel = path.join(modelsDir, 'rin.pmdl');

/**
 * Initialize wake word detection with Snowboy
 * @param {Function} callback - Function to call when wake word is detected
 * @param {Object} options - Configuration options
 * @returns {Object} - Control object with stop function
 */
function initWakeWordDetection(callback, options = {}) {
  // Default options
  const modelPath = options.modelPath || defaultWakeWordModel;
  const sensitivity = options.sensitivity || '0.5';
  const audioGain = options.audioGain || 2.0;
  const hotwords = options.hotwords || 'rin';
  const debug = options.debug || false;

  // Verify model exists
  if (!fs.existsSync(modelPath)) {
    console.error(`Wake word model not found at ${modelPath}. Please provide a valid model file.`);
    return { stop: () => {} };
  }

  // Configure the models
  const models = new Models();
  models.add({
    file: modelPath,
    sensitivity: sensitivity,
    hotwords: hotwords
  });

  // Create the detector
  const detector = new Detector({
    resource: path.join(__dirname, '../node_modules/snowboy/resources/common.res'),
    models: models,
    audioGain: audioGain
  });

  // Log when in debug mode
  if (debug) {
    detector.on('silence', () => console.log('Silence detected'));
    detector.on('sound', () => console.log('Sound detected'));
  }

  // Wake word detection event
  detector.on('hotword', (index, hotword, buffer) => {
    console.log(`Wake word detected: ${hotword}`);
    callback(hotword, buffer);
  });

  detector.on('error', error => {
    console.error('Wake word detection error:', error);
  });

  // Start recording and pipe to detector
  console.log('Listening for wake word... Press Ctrl+C to exit.');
  let isListening = true;
  const recordingStream = record.start({
    threshold: 0,
    sampleRate: 16000,
    recordProgram: options.recordProgram || 'rec',
    verbose: debug
  })
  .on('error', error => {
    console.error('Recording error:', error);
    isListening = false;
  });

  // Pipe audio to detector
  recordingStream.pipe(detector);

  // Return control object
  return {
    stop: () => {
      if (isListening) {
        isListening = false;
        recordingStream.stop();
        console.log('Wake word detection stopped');
      }
    },
    isListening: () => isListening
  };
}

/**
 * Helper function to train a custom wake word model
 * This is a mock function - in a real app you would 
 * implement a proper training process or use a service
 * 
 * @param {string} wakeWord - The wake word to train
 * @param {string} outputPath - Where to save the model
 */
function trainCustomWakeWord(wakeWord, outputPath) {
  console.log(`Training for wake word "${wakeWord}" is not implemented in this prototype.`);
  console.log('For a production app, you would:');
  console.log('1. Record multiple samples of the wake word');
  console.log('2. Use Snowboy\'s API to train a model');
  console.log('3. Save the model to the specified path');
  console.log('See https://github.com/Kitt-AI/snowboy for more information');
}

module.exports = { 
  initWakeWordDetection,
  trainCustomWakeWord
};
```

</details>

## Web Search Integration Rule

This rule helps you implement web search functionality using SerpAPI and summarization with OpenAI.

<details>
<summary>**Click to see the complete Web Search Integration rule**</summary>

```
# Rin V0 Web Search Integration Rule
# This rule helps with implementing web search functionality using SerpAPI and OpenAI

# Define which files this rule applies to
*.js
src/search.js
src/services/search-service.js
src/api/serpapi.js

# Rule content below
When helping with the Rin V0 Web Search Integration:

1. SerpAPI Integration:
   - Use serpapi npm package for search functionality
   - Configure with proper API key from environment variables
   - Implement search function with query parameter
   - Extract relevant information from search results
   - Handle pagination and result limits
   - Support different search engines if needed
   - Document API rate limits and usage

2. Search Response Processing:
   - Extract titles, snippets, and links from results
   - Format search results for easy consumption
   - Handle various result types (organic, answers, knowledge panels)
   - Limit results to relevant information
   - Filter out low-quality or irrelevant results
   - Preserve citation information for credibility
   - Support different result formats based on context

3. OpenAI Summarization Integration:
   - Use OpenAI API to summarize search results
   - Craft effective prompts for summarization
   - Configure appropriate model and parameters
   - Combine multiple search results into a coherent summary
   - Preserve factual accuracy in summarization
   - Handle long inputs with proper context management
   - Support different summarization styles (concise, detailed)

4. Error Handling:
   - Handle API errors from SerpAPI
   - Manage rate limiting and quota issues
   - Implement fallback search mechanisms
   - Handle failed or empty searches gracefully
   - Provide meaningful error messages
   - Log search problems for debugging
   - Implement retry logic for transient failures

5. Performance Optimization:
   - Cache common searches for performance
   - Implement request timeouts
   - Use proper pagination when needed
   - Optimize result processing for speed
   - Monitor API usage for cost optimization
   - Support asynchronous search operations
   - Implement query throttling for frequent searches

6. Integration with CLI:
   - Add search command to CLI interface
   - Format search results for console display
   - Support search result storage in interaction history
   - Provide command line options for search parameters
   - Implement help and usage information
   - Support output redirection to files
   - Enable interactive search refinement
```

</details>

### Implementation Examples

<details>
<summary>**Example Web Search Setup**</summary>

```javascript
// src/search.js
const { getJson } = require('serpapi');
const OpenAI = require('openai');

// Initialize OpenAI with API key
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

/**
 * Perform a web search using SerpAPI
 * @param {string} query - The search query
 * @param {Object} options - Search options
 * @returns {Promise<Array>} - Array of search results
 */
async function webSearch(query, options = {}) {
  try {
    // Default options
    const engine = options.engine || 'google';
    const numResults = options.numResults || 5;
    const timeout = options.timeout || 10000; // 10 seconds

    console.log(`Searching for: "${query}" using ${engine}`);

    // Build search parameters
    const searchParams = {
      q: query,
      api_key: process.env.SERPAPI_API_KEY,
      engine: engine
    };

    // Add optional parameters if provided
    if (options.location) searchParams.location = options.location;
    if (options.gl) searchParams.gl = options.gl; // Country code
    if (options.hl) searchParams.hl = options.hl; // Language code

    // Create a timeout promise
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Search request timed out')), timeout);
    });

    // Execute search with timeout
    const response = await Promise.race([
      getJson(searchParams),
      timeoutPromise
    ]);

    // Process organic search results
    let results = [];
    
    // Extract organic results
    if (response.organic_results && response.organic_results.length > 0) {
      results = response.organic_results
        .slice(0, numResults)
        .map(result => ({
          title: result.title,
          link: result.link,
          snippet: result.snippet || 'No description available',
          position: result.position,
          source: 'organic'
        }));
    }
    
    // Extract knowledge panel if available
    if (response.knowledge_graph) {
      const kg = response.knowledge_graph;
      results.push({
        title: kg.title || 'Knowledge Panel',
        link: kg.website || '',
        snippet: kg.description || 'No description available',
        source: 'knowledge_graph'
      });
    }
    
    // Extract answer box if available
    if (response.answer_box) {
      const answerBox = response.answer_box;
      results.push({
        title: answerBox.title || 'Answer',
        link: answerBox.link || '',
        snippet: answerBox.answer || answerBox.snippet || 'No answer available',
        source: 'answer_box'
      });
    }

    console.log(`Found ${results.length} results`);
    return results;
  } catch (error) {
    console.error('Error during web search:', error.message);
    throw new Error(`Search failed: ${error.message}`);
  }
}

/**
 * Search the web and summarize results using OpenAI
 * @param {string} query - The search query
 * @param {Object} options - Search and summarization options
 * @returns {Promise<string>} - Summarized search results
 */
async function searchAndSummarize(query, options = {}) {
  try {
    // Perform web search
    const searchResults = await webSearch(query, options);
    
    if (searchResults.length === 0) {
      return "I couldn't find any relevant information for your query.";
    }
    
    // Format search results for the LLM
    const resultsText = searchResults.map((result, i) => 
      `[${i+1}] ${result.title}\n${result.snippet}\nURL: ${result.link}`
    ).join('\n\n');
    
    // Determine summarization style
    const style = options.style || 'concise';
    let stylePrompt = '';
    
    if (style === 'concise') {
      stylePrompt = 'Provide a concise 2-3 sentence summary.';
    } else if (style === 'detailed') {
      stylePrompt = 'Provide a comprehensive summary with key points and details.';
    } else if (style === 'bullet') {
      stylePrompt = 'Provide a summary as a bulleted list of key points.';
    }
    
    // Create summarization prompt
    const summarizationPrompt = 
      `Please summarize these search results for the query: "${query}".
      
      ${resultsText}
      
      ${stylePrompt}
      Include the most relevant information and maintain factual accuracy.
      Cite sources by referring to their numbers [1], [2], etc.`;
    
    // Use OpenAI to summarize
    const response = await openai.chat.completions.create({
      model: options.model || 'gpt-4',
      messages: [
        { 
          role: 'system', 
          content: 'You are a helpful assistant that summarizes web search results accurately and objectively.' 
        },
        { 
          role: 'user', 
          content: summarizationPrompt
        }
      ],
      temperature: options.temperature || 0.5,
      max_tokens: options.maxTokens || 500
    });
    
    return response.choices[0].message.content;
  } catch (error) {
    console.error('Error in search and summarize:', error.message);
    return `Sorry, I encountered an error while searching: ${error.message}`;
  }
}

/**
 * Cache for storing search results to minimize API calls
 */
const searchCache = {
  data: {},
  maxSize: 50,
  
  /**
   * Get cached search result
   * @param {string} query - The search query
   * @returns {Object|null} - Cached result or null
   */
  get(query) {
    const normalizedQuery = query.toLowerCase().trim();
    const cachedResult = this.data[normalizedQuery];
    
    if (cachedResult) {
      const now = Date.now();
      const age = now - cachedResult.timestamp;
      
      // Return if cache is less than 1 hour old
      if (age < 3600000) {
        console.log(`Using cached result for "${query}" (${Math.round(age/1000/60)} minutes old)`);
        return cachedResult.result;
      }
      
      // Remove expired cache
      delete this.data[normalizedQuery];
    }
    
    return null;
  },
  
  /**
   * Store search result in cache
   * @param {string} query - The search query
   * @param {Object} result - The search result
   */
  set(query, result) {
    const normalizedQuery = query.toLowerCase().trim();
    
    // Check cache size and remove oldest entry if full
    const keys = Object.keys(this.data);
    if (keys.length >= this.maxSize) {
      let oldest = keys[0];
      let oldestTime = this.data[oldest].timestamp;
      
      for (const key of keys) {
        if (this.data[key].timestamp < oldestTime) {
          oldest = key;
          oldestTime = this.data[key].timestamp;
        }
      }
      
      delete this.data[oldest];
    }
    
    // Add to cache
    this.data[normalizedQuery] = {
      result: result,
      timestamp: Date.now()
    };
  }
};

module.exports = { 
  webSearch, 
  searchAndSummarize,
  searchCache
};
```

</details>

## Telegram Bot Integration Rule

This rule helps you implement a Telegram bot interface for Rin.

<details>
<summary>**Click to see the complete Telegram Bot Integration rule**</summary>

```
# Rin V0 Telegram Bot Integration Rule
# This rule helps with implementing a Telegram bot interface for Rin

# Define which files this rule applies to
*.js
src/telegram.js
src/services/telegram-service.js
src/bots/*.js

# Rule content below
When helping with the Rin V0 Telegram Bot Integration:

1. Telegram Bot Setup:
   - Use node-telegram-bot-api package
   - Configure with bot token from environment variables
   - Initialize bot with proper options (polling vs. webhook)
   - Set up proper event handlers for messages
   - Implement command pattern recognition
   - Support both text and voice messages
   - Document bot creation process with BotFather

2. Message Handling:
   - Process incoming messages properly
   - Extract message text and metadata
   - Support command parsing (/start, /help, etc.)
   - Handle different message types (text, voice, images)
   - Implement user session management
   - Support conversation context
   - Handle command arguments correctly

3. OpenAI Integration:
   - Connect bot responses to OpenAI API
   - Maintain conversation context per user
   - Format AI responses properly for Telegram
   - Support system message configuration
   - Handle message length limitations
   - Implement typing indicators during processing
   - Support conversation memory and history

4. Error Handling:
   - Manage Telegram API errors
   - Handle OpenAI API failures
   - Implement retry logic for transient issues
   - Provide friendly error messages to users
   - Log errors for debugging purposes
   - Support graceful degradation
   - Implement timeouts for long-running operations

5. User Experience:
   - Add helpful command descriptions
   - Implement inline keyboards where appropriate
   - Support rich formatting in messages
   - Add typing indicators during processing
   - Provide clear help and instructions
   - Implement welcome message for new users
   - Support message reactions and feedback

6. Security Considerations:
   - Implement user authentication if needed
   - Store user data securely
   - Sanitize all user inputs
   - Implement command access controls
   - Add rate limiting for heavy users
   - Support blocking problematic users
   - Document privacy considerations for users
```

</details>

### Implementation Examples

<details>
<summary>**Example Telegram Bot Setup**</summary>

```javascript
// src/telegram.js
const TelegramBot = require('node-telegram-bot-api');
const OpenAI = require('openai');
const storage = require('./storage');

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Map to store user conversation contexts
const userContexts = new Map();

// Default system message
const DEFAULT_SYSTEM_MESSAGE = 'You are Rin, a helpful personal assistant. Be concise, friendly, and useful.';

/**
 * Initialize the Telegram bot
 * @param {Object} options - Bot configuration options
 * @returns {TelegramBot} - Initialized bot instance
 */
function initBot(options = {}) {
  // Validate bot token
  const token = process.env.TELEGRAM_BOT_TOKEN;
  if (!token) {
    throw new Error('TELEGRAM_BOT_TOKEN not found in environment variables');
  }

  // Default options
  const usePolling = options.usePolling !== undefined ? options.usePolling : true;
  const botOptions = usePolling 
    ? { polling: true } 
    : { webHook: { port: options.port || 8443 } };

  console.log(`Initializing Telegram bot with ${usePolling ? 'polling' : 'webhook'} mode`);
  
  // Create bot instance
  const bot = new TelegramBot(token, botOptions);
  
  // Set webhook if using webhook mode
  if (!usePolling && options.webHookUrl) {
    bot.setWebHook(`${options.webHookUrl}/bot${token}`);
    console.log(`Webhook set to ${options.webHookUrl}`);
  }

  // Handle start command
  bot.onText(/\/start/, (msg) => {
    const chatId = msg.chat.id;
    const firstName = msg.from.first_name || 'there';
    
    bot.sendMessage(
      chatId,
      `👋 Hello ${firstName}! I'm Rin, your personal assistant. You can ask me questions, request information, or just chat with me.
      
Try some of these commands:
/help - Show available commands
/remember - View our conversation history
/clear - Clear our conversation history
      
Or just send me a message and I'll respond!`
    );
  });

  // Handle help command
  bot.onText(/\/help/, (msg) => {
    const chatId = msg.chat.id;
    
    bot.sendMessage(
      chatId,
      `Available commands:
      
/start - Start or restart our conversation
/help - Show this help message
/remember - View our past conversations
/clear - Clear our conversation history
/search <query> - Search the web for information
/weather <location> - Get weather forecast (mock)
      
You can also send me voice messages and I'll respond to them!`
    );
  });

  // Handle remember command
  bot.onText(/\/remember/, async (msg) => {
    const chatId = msg.chat.id;
    
    try {
      bot.sendChatAction(chatId, 'typing');
      
      // Get past interactions for this user
      const interactions = await storage.getInteractionsByUser(msg.from.id.toString());
      
      if (interactions.length === 0) {
        bot.sendMessage(chatId, "We haven't had any conversations yet!");
        return;
      }
      
      // Format past interactions
      let responseText = '📝 Here are our past conversations:\n\n';
      
      const maxInteractions = Math.min(interactions.length, 5); // Limit to last 5
      for (let i = 0; i < maxInteractions; i++) {
        const interaction = interactions[i];
        responseText += `You: ${interaction.query}\n`;
        responseText += `Rin: ${interaction.response}\n\n`;
      }
      
      if (interactions.length > 5) {
        responseText += `(Showing ${maxInteractions} of ${interactions.length} total interactions)`;
      }
      
      bot.sendMessage(chatId, responseText);
    } catch (error) {
      console.error('Error retrieving interactions:', error);
      bot.sendMessage(chatId, 'Sorry, I had trouble retrieving our conversation history.');
    }
  });

  // Handle clear command
  bot.onText(/\/clear/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id.toString();
    
    try {
      // Clear user context
      userContexts.delete(userId);
      
      // Clear interactions from storage
      await storage.clearInteractionsByUser(userId);
      
      bot.sendMessage(chatId, '🗑️ I've cleared our conversation history. We're starting fresh!');
    } catch (error) {
      console.error('Error clearing interactions:', error);
      bot.sendMessage(chatId, 'Sorry, I had trouble clearing our conversation history.');
    }
  });

  // Handle search command
  bot.onText(/\/search (.+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const query = match[1];
    
    bot.sendChatAction(chatId, 'typing');
    bot.sendMessage(chatId, `🔍 Searching for: "${query}"`);
    
    try {
      // Import search module
      const search = require('./search');
      
      // Show typing indicator during search
      const typingInterval = setInterval(() => {
        bot.sendChatAction(chatId, 'typing');
      }, 3000);
      
      // Perform search
      const summary = await search.searchAndSummarize(query);
      
      // Stop typing indicator
      clearInterval(typingInterval);
      
      // Send results
      bot.sendMessage(chatId, summary);
      
      // Store interaction
      await storage.saveInteraction(
        `/search ${query}`, 
        summary,
        msg.from.id.toString()
      );
    } catch (error) {
      console.error('Search error:', error);
      bot.sendMessage(chatId, `Sorry, I encountered an error while searching: ${error.message}`);
    }
  });

  // Handle voice messages
  bot.on('voice', async (msg) => {
    const chatId = msg.chat.id;
    
    // Notify user
    bot.sendMessage(chatId, "I received your voice message, but voice recognition isn't implemented in this prototype yet.");
    
    // In a real implementation:
    // 1. Download the voice file (bot.getFileLink)
    // 2. Convert to format required by STT API
    // 3. Use speech recognition to get text
    // 4. Process the text as a regular message
  });

  // Handle regular messages
  bot.on('message', async (msg) => {
    // Skip commands and non-text messages
    if (msg.entities || !msg.text || msg.text.startsWith('/')) {
      return;
    }
    
    const chatId = msg.chat.id;
    const userId = msg.from.id.toString();
    const userInput = msg.text;
    
    // Show typing indicator
    bot.sendChatAction(chatId, 'typing');
    
    try {
      // Get or initialize user context
      let userContext = userContexts.get(userId);
      if (!userContext) {
        userContext = {
          messages: [
            { role: 'system', content: DEFAULT_SYSTEM_MESSAGE }
          ]
        };
        userContexts.set(userId, userContext);
      }
      
      // Add user message to context
      userContext.messages.push({ role: 'user', content: userInput });
      
      // Keep context window limited (last 10 messages)
      if (userContext.messages.length > 11) { // system + 10 messages
        userContext.messages = [
          userContext.messages[0], // Keep system message
          ...userContext.messages.slice(-10) // Keep last 10 messages
        ];
      }
      
      // Send to OpenAI
      const response = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: userContext.messages,
        temperature: 0.7,
        max_tokens: 500
      });
      
      const answer = response.choices[0].message.content;
      
      // Add assistant response to context
      userContext.messages.push({ role: 'assistant', content: answer });
      
      // Save to storage
      await storage.saveInteraction(
        userInput,
        answer,
        userId
      );
      
      // Send response
      bot.sendMessage(chatId, answer);
    } catch (error) {
      console.error('Error processing message:', error);
      bot.sendMessage(chatId, 'Sorry, I encountered an error processing your message.');
    }
  });

  // Handle errors
  bot.on('polling_error', (error) => {
    console.error('Telegram polling error:', error);
  });
  
  bot.on('webhook_error', (error) => {
    console.error('Telegram webhook error:', error);
  });
  
  bot.on('error', (error) => {
    console.error('Telegram bot error:', error);
  });

  console.log('Telegram bot initialized');
  return bot;
}

module.exports = { initBot };
```

</details>

## List Storage & Reminder System Rule

This rule helps you extend the storage functionality to handle lists and reminders.

<details>
<summary>**Click to see the complete List Storage & Reminder System rule**</summary>

```
# Rin V0 List Storage & Reminder System Rule
# This rule helps with implementing list storage and reminder functionality

# Define which files this rule applies to
*.js
src/storage.js
src/reminders.js
src/lists.js
src/services/reminder-service.js

# Rule content below
When helping with the Rin V0 List Storage & Reminder System:

1. List Storage Database Schema:
   - Extend the SQLite database to store lists
   - Create tables with appropriate schema
   - Support list names and items as JSON
   - Implement proper indexes for performance
   - Support user-specific lists if needed
   - Add timestamps for creation and updates
   - Design schema for future extensibility

2. List API Implementation:
   - Create functions for CRUD operations on lists
   - Implement saveList functionality
   - Support retrieving lists by name
   - Enable list item additions and removals
   - Add support for list updates
   - Implement list deletion
   - Format list data for display

3. Reminder Database Schema:
   - Create table for storing reminders
   - Include text, timestamp, and status fields
   - Add user identifier if applicable
   - Support recurrence patterns (optional)
   - Add completion status tracking
   - Implement proper indexing for time-based queries
   - Support categories or tags for organization

4. Reminder API Implementation:
   - Create functions for CRUD operations on reminders
   - Implement createReminder functionality
   - Support retrieving active reminders
   - Enable reminder updates and deletion
   - Add functions to mark reminders as completed
   - Support querying upcoming reminders
   - Format reminder data for display

5. Reminder Service:
   - Implement background checking for due reminders
   - Create notification mechanism for due reminders
   - Support graceful service start/stop
   - Handle errors in the reminder service
   - Implement proper cleanup of completed reminders
   - Add logging of reminder activities
   - Document how to configure the service

6. CLI Integration:
   - Add commands for list management
   - Implement commands for reminder creation and management
   - Format list and reminder output for the console
   - Support natural language time parsing for reminders
   - Create help documentation for the commands
   - Implement interactive list editing if possible
   - Support export/import of lists and reminders
```

</details>

### Implementation Examples

<details>
<summary>**Example List Storage Setup**</summary>

```javascript
// src/storage.js (additional functions for list storage)

// Add these functions to your existing storage.js file

/**
 * Save a list to the database
 * @param {string} listName - Name of the list
 * @param {Array} items - Array of list items
 * @param {string} userId - Optional user identifier
 * @returns {Promise<number>} - ID of the saved list
 */
function saveList(listName, items, userId = 'default') {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject(new Error('Database not initialized. Call init() first.'));
    }

    db.serialize(() => {
      // Create lists table if it doesn't exist
      db.run(`
        CREATE TABLE IF NOT EXISTS lists (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL,
          items TEXT NOT NULL,
          user_id TEXT NOT NULL,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          UNIQUE(name, user_id)
        )
      `, (err) => {
        if (err) {
          console.error('Error creating lists table:', err);
          return reject(err);
        }

        // Convert items array to JSON string
        const itemsJson = JSON.stringify(items);

        // Using INSERT OR REPLACE for upsert functionality
        db.run(
          `INSERT OR REPLACE INTO lists (name, items, user_id, updated_at) 
           VALUES (?, ?, ?, CURRENT_TIMESTAMP)`,
          [listName, itemsJson, userId],
          function(err) {
            if (err) {
              console.error('Error saving list:', err);
              return reject(err);
            }
            console.log(`List "${listName}" saved with ${items.length} items for user ${userId}`);
            resolve(this.lastID);
          }
        );
      });
    });
  });
}

/**
 * Get a list by name
 * @param {string} listName - Name of the list to retrieve
 * @param {string} userId - Optional user identifier
 * @returns {Promise<Array|null>} - Array of list items or null if not found
 */
function getList(listName, userId = 'default') {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject(new Error('Database not initialized. Call init() first.'));
    }

    db.get(
      'SELECT * FROM lists WHERE name = ? AND user_id = ?',
      [listName, userId],
      (err, row) => {
        if (err) {
          console.error('Error retrieving list:', err);
          return reject(err);
        }

        if (!row) {
          return resolve(null); // List not found
        }

        try {
          // Parse the JSON items
          const items = JSON.parse(row.items);
          resolve(items);
        } catch (parseErr) {
          console.error('Error parsing list items:', parseErr);
          reject(new Error('Failed to parse list data'));
        }
      }
    );
  });
}

/**
 * Get all lists for a user
 * @param {string} userId - User identifier
 * @returns {Promise<Array>} - Array of list objects
 */
function getLists(userId = 'default') {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject(new Error('Database not initialized. Call init() first.'));
    }

    db.all(
      'SELECT id, name, created_at, updated_at FROM lists WHERE user_id = ?',
      [userId],
      (err, rows) => {
        if (err) {
          console.error('Error retrieving lists:', err);
          return reject(err);
        }

        console.log(`Retrieved ${rows.length} lists for user ${userId}`);
        resolve(rows);
      }
    );
  });
}

/**
 * Delete a list
 * @param {string} listName - Name of the list to delete
 * @param {string} userId - Optional user identifier
 * @returns {Promise<boolean>} - True if list was deleted
 */
function deleteList(listName, userId = 'default') {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject(new Error('Database not initialized. Call init() first.'));
    }

    db.run(
      'DELETE FROM lists WHERE name = ? AND user_id = ?',
      [listName, userId],
      function(err) {
        if (err) {
          console.error('Error deleting list:', err);
          return reject(err);
        }

        console.log(`List "${listName}" deleted for user ${userId}`);
        resolve(this.changes > 0);
      }
    );
  });
}

/**
 * Add item to a list
 * @param {string} listName - Name of the list
 * @param {string} item - Item to add
 * @param {string} userId - Optional user identifier
 * @returns {Promise<boolean>} - True if item was added
 */
function addListItem(listName, item, userId = 'default') {
  return new Promise(async (resolve, reject) => {
    try {
      // Get current list
      const items = await getList(listName, userId) || [];
      
      // Add item if not already in list
      if (!items.includes(item)) {
        items.push(item);
        await saveList(listName, items, userId);
        resolve(true);
      } else {
        resolve(false); // Item already exists
      }
    } catch (err) {
      console.error('Error adding list item:', err);
      reject(err);
    }
  });
}

/**
 * Remove item from a list
 * @param {string} listName - Name of the list
 * @param {string} item - Item to remove
 * @param {string} userId - Optional user identifier
 * @returns {Promise<boolean>} - True if item was removed
 */
function removeListItem(listName, item, userId = 'default') {
  return new Promise(async (resolve, reject) => {
    try {
      // Get current list
      const items = await getList(listName, userId);
      
      if (!items) {
        resolve(false); // List not found
        return;
      }
      
      // Find and remove item
      const index = items.indexOf(item);
      if (index !== -1) {
        items.splice(index, 1);
        await saveList(listName, items, userId);
        resolve(true);
      } else {
        resolve(false); // Item not found
      }
    } catch (err) {
      console.error('Error removing list item:', err);
      reject(err);
    }
  });
}

// Add these exports to your module.exports
module.exports.saveList = saveList;
module.exports.getList = getList;
module.exports.getLists = getLists;
module.exports.deleteList = deleteList;
module.exports.addListItem = addListItem;
module.exports.removeListItem = removeListItem;
```

</details>

<details>
<summary>**Example Reminder System**</summary>

```javascript
// src/storage.js (additional functions for reminders)

// Add these functions to your existing storage.js file

/**
 * Create a new reminder
 * @param {string} text - Reminder text
 * @param {string} remindAt - ISO datetime string for when to remind
 * @param {string} userId - Optional user identifier
 * @returns {Promise<number>} - ID of the created reminder
 */
function createReminder(text, remindAt, userId = 'default') {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject(new Error('Database not initialized. Call init() first.'));
    }

    db.serialize(() => {
      // Create reminders table if it doesn't exist
      db.run(`
        CREATE TABLE IF NOT EXISTS reminders (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          text TEXT NOT NULL,
          remind_at DATETIME NOT NULL,
          user_id TEXT NOT NULL,
          completed INTEGER DEFAULT 0,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
      `, (err) => {
        if (err) {
          console.error('Error creating reminders table:', err);
          return reject(err);
        }

        // Create index on remind_at for faster queries
        db.run(`
          CREATE INDEX IF NOT EXISTS idx_reminders_remind_at 
          ON reminders(remind_at)
        `, (err) => {
          if (err) {
            console.error('Error creating reminders index:', err);
            // Continue anyway, index is not critical
          }

          // Insert the reminder
          db.run(
            'INSERT INTO reminders (text, remind_at, user_id) VALUES (?, ?, ?)',
            [text, remindAt, userId],
            function(err) {
              if (err) {
                console.error('Error creating reminder:', err);
                return reject(err);
              }
              console.log(`Reminder created with ID ${this.lastID} for ${remindAt}`);
              resolve(this.lastID);
            }
          );
        });
      });
    });
  });
}

/**
 * Get all pending reminders (due and not completed)
 * @returns {Promise<Array>} - Array of pending reminders
 */
function getPendingReminders() {
  const now = new Date().toISOString();
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject(new Error('Database not initialized. Call init() first.'));
    }

    db.all(
      'SELECT * FROM reminders WHERE remind_at <= ? AND completed = 0',
      [now],
      (err, rows) => {
        if (err) {
          console.error('Error retrieving pending reminders:', err);
          return reject(err);
        }

        console.log(`Found ${rows.length} pending reminders`);
        resolve(rows);
      }
    );
  });
}

/**
 * Get upcoming reminders for a user
 * @param {string} userId - User identifier
 * @param {number} limit - Maximum number of reminders to retrieve
 * @returns {Promise<Array>} - Array of upcoming reminders
 */
function getUpcomingReminders(userId = 'default', limit = 10) {
  const now = new Date().toISOString();
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject(new Error('Database not initialized. Call init() first.'));
    }

    db.all(
      `SELECT * FROM reminders 
       WHERE user_id = ? AND completed = 0 AND remind_at > ?
       ORDER BY remind_at ASC
       LIMIT ?`,
      [userId, now, limit],
      (err, rows) => {
        if (err) {
          console.error('Error retrieving upcoming reminders:', err);
          return reject(err);
        }

        console.log(`Found ${rows.length} upcoming reminders for user ${userId}`);
        resolve(rows);
      }
    );
  });
}

/**
 * Mark a reminder as completed
 * @param {number} id - Reminder ID
 * @returns {Promise<boolean>} - True if reminder was updated
 */
function markReminderCompleted(id) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject(new Error('Database not initialized. Call init() first.'));
    }

    db.run(
      'UPDATE reminders SET completed = 1 WHERE id = ?',
      [id],
      function(err) {
        if (err) {
          console.error('Error marking reminder as completed:', err);
          return reject(err);
        }

        console.log(`Marked reminder ${id} as completed`);
        resolve(this.changes > 0);
      }
    );
  });
}

/**
 * Delete a reminder
 * @param {number} id - Reminder ID
 * @param {string} userId - User identifier
 * @returns {Promise<boolean>} - True if reminder was deleted
 */
function deleteReminder(id, userId = 'default') {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject(new Error('Database not initialized. Call init() first.'));
    }

    db.run(
      'DELETE FROM reminders WHERE id = ? AND user_id = ?',
      [id, userId],
      function(err) {
        if (err) {
          console.error('Error deleting reminder:', err);
          return reject(err);
        }

        console.log(`Deleted reminder ${id} for user ${userId}`);
        resolve(this.changes > 0);
      }
    );
  });
}

// Add these exports to your module.exports
module.exports.createReminder = createReminder;
module.exports.getPendingReminders = getPendingReminders;
module.exports.getUpcomingReminders = getUpcomingReminders;
module.exports.markReminderCompleted = markReminderCompleted;
module.exports.deleteReminder = deleteReminder;
```

</details>

## Email Draft Functionality Rule

This rule helps you implement email draft generation using OpenAI.

<details>
<summary>**Click to see the complete Email Draft Functionality rule**</summary>

```
# Rin V0 Email Draft Functionality Rule
# This rule helps with implementing email draft generation using OpenAI

# Define which files this rule applies to
*.js
src/email.js
src/services/email-service.js

# Rule content below
When helping with the Rin V0 Email Draft Functionality:

1. Email Draft Generation:
   - Use OpenAI API for generating email content
   - Create appropriate system prompts for different email types
   - Support various email formats (formal, casual, etc.)
   - Implement content structure with proper headers
   - Format email text with proper spacing
   - Support customization of email style
   - Enable regeneration of unsatisfactory drafts

2. Draft Storage and Management:
   - Create a storage system for email drafts
   - Save drafts to filesystem with proper naming
   - Support retrieving drafts by identifier
   - Implement listing of saved drafts
   - Enable draft modification and updates
   - Support draft deletion
   - Implement draft categorization if needed

3. Email Metadata Handling:
   - Support proper email header formatting
   - Handle To, From, Subject, and CC fields
   - Support attachment references
   - Format dates according to RFC standards
   - Validate email addresses
   - Support multiple recipients
   - Sanitize input data for security

4. User Interface:
   - Create CLI commands for email draft creation
   - Support interactive email composition
   - Implement draft previewing
   - Enable draft editing after generation
   - Add commands for managing saved drafts
   - Provide clear usage instructions
   - Format email drafts for display

5. Error Handling:
   - Validate input parameters
   - Handle OpenAI API errors gracefully
   - Implement fallbacks for failed generation
   - Check for file system access issues
   - Provide meaningful error messages
   - Log detailed error information
   - Support retries for transient failures

6. Integration with CLI:
   - Add email draft command to CLI interface
   - Support command line parameters for email fields
   - Enable interactive mode for complex drafts
   - Format output for console display
   - Support email draft storage
   - Provide examples in help documentation
   - Add support for template-based drafts
```

</details>

### Implementation Examples

<details>
<summary>**Example Email Draft Setup**</summary>

```javascript
// src/email.js
const fs = require('fs');
const path = require('path');
const OpenAI = require('openai');
const { v4: uuidv4 } = require('uuid');

// Initialize OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Ensure drafts directory exists
const draftsDir = path.join(process.env.HOME || process.env.USERPROFILE, '.rin', 'email-drafts');
fs.mkdirSync(draftsDir, { recursive: true });

/**
 * Create an email draft using OpenAI
 * @param {Object} params - Email parameters
 * @param {string} params.to - Recipient email address(es)
 * @param {string} params.subject - Email subject
 * @param {string} params.content - Content description or instructions
 * @param {string} params.style - Email style (formal, casual, etc.)
 * @returns {Promise<Object>} - Result with draft content and path
 */
async function createEmailDraft(params) {
  try {
    // Validate parameters
    if (!params.to) throw new Error('Recipient (to) is required');
    if (!params.subject) throw new Error('Subject is required');
    if (!params.content) throw new Error('Content description is required');
    
    // Default style is professional
    const style = params.style || 'professional';
    
    // Define style instructions
    let stylePrompt = '';
    switch (style.toLowerCase()) {
      case 'formal':
        stylePrompt = 'Write a formal email using professional language and proper business etiquette.';
        break;
      case 'casual':
        stylePrompt = 'Write a casual, friendly email while maintaining professionalism.';
        break;
      case 'concise':
        stylePrompt = 'Write a brief, to-the-point email focusing only on essential information.';
        break;
      default:
        stylePrompt = 'Write a professional email with clear and concise language.';
    }
    
    // Generate email using OpenAI
    const response = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        { 
          role: 'system', 
          content: `You are an email writing assistant. ${stylePrompt} Do not include any annotations or explanations - only provide the email body content.` 
        },
        { 
          role: 'user', 
          content: `Draft an email with the following details:
          To: ${params.to}
          Subject: ${params.subject}
          Content: ${params.content}
          
          The email should be well-structured with proper greeting and closing.` 
        }
      ],
      temperature: 0.7,
      max_tokens: 1000
    });
    
    const emailContent = response.choices[0].message.content.trim();
    
    // Format complete email with headers
    const emailData = `To: ${params.to}
Subject: ${params.subject}
Date: ${new Date().toUTCString()}

${emailContent}`;
    
    // Generate unique ID for the draft
    const draftId = uuidv4().slice(0, 8);
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `email_draft_${draftId}_${timestamp}.txt`;
    const filePath = path.join(draftsDir, filename);
    
    // Save to file
    fs.writeFileSync(filePath, emailData, 'utf8');
    
    return {
      success: true,
      id: draftId,
      path: filePath,
      filename: filename,
      content: emailData,
      to: params.to,
      subject: params.subject
    };
  } catch (error) {
    console.error('Error creating email draft:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Get a list of saved email drafts
 * @returns {Promise<Array>} - Array of draft objects
 */
function listEmailDrafts() {
  return new Promise((resolve, reject) => {
    try {
      // Read draft directory
      const files = fs.readdirSync(draftsDir);
      
      // Filter for email draft files
      const drafts = files
        .filter(file => file.startsWith('email_draft_'))
        .map(file => {
          const filePath = path.join(draftsDir, file);
          const stats = fs.statSync(filePath);
          
          // Extract draft ID from filename
          const idMatch = file.match(/email_draft_([a-f0-9]+)_/);
          const id = idMatch ? idMatch[1] : 'unknown';
          
          // Get preview of content
          let preview = '';
          let to = '';
          let subject = '';
          
          try {
            const content = fs.readFileSync(filePath, 'utf8');
            const lines = content.split('\n');
            
            // Extract metadata
            for (const line of lines) {
              if (line.startsWith('To:')) to = line.substring(3).trim();
              if (line.startsWith('Subject:')) subject = line.substring(8).trim();
              if (!line.includes(':') && line.trim() !== '') {
                preview = line.trim();
                break;
              }
            }
          } catch (err) {
            console.error(`Error reading draft ${file}:`, err);
          }
          
          return {
            id,
            filename: file,
            path: filePath,
            created: stats.birthtime,
            size: stats.size,
            to,
            subject,
            preview: preview.length > 50 ? preview.substring(0, 47) + '...' : preview
          };
        });
      
      // Sort by creation date (newest first)
      drafts.sort((a, b) => b.created - a.created);
      
      resolve(drafts);
    } catch (error) {
      console.error('Error listing email drafts:', error);
      reject(error);
    }
  });
}

/**
 * Get a specific email draft by ID
 * @param {string} draftId - The ID of the draft to retrieve
 * @returns {Promise<Object>} - Draft content and metadata
 */
function getEmailDraft(draftId) {
  return new Promise((resolve, reject) => {
    try {
      // Read draft directory
      const files = fs.readdirSync(draftsDir);
      
      // Find the specific draft file
      const draftFile = files.find(file => file.includes(`email_draft_${draftId}_`));
      
      if (!draftFile) {
        return reject(new Error(`Draft with ID ${draftId} not found`));
      }
      
      const filePath = path.join(draftsDir, draftFile);
      const content = fs.readFileSync(filePath, 'utf8');
      
      // Parse email content
      let to = '';
      let subject = '';
      let date = '';
      let body = '';
      
      const lines = content.split('\n');
      let inHeader = true;
      
      for (const line of lines) {
        if (inHeader) {
          if (line.trim() === '') {
            inHeader = false;
            continue;
          }
          if (line.startsWith('To:')) to = line.substring(3).trim();
          if (line.startsWith('Subject:')) subject = line.substring(8).trim();
          if (line.startsWith('Date:')) date = line.substring(5).trim();
        } else {
          body += line + '\n';
        }
      }
      
      resolve({
        id: draftId,
        filename: draftFile,
        path: filePath,
        to,
        subject,
        date,
        body: body.trim(),
        content
      });
    } catch (error) {
      console.error(`Error retrieving draft ${draftId}:`, error);
      reject(error);
    }
  });
}

/**
 * Delete an email draft
 * @param {string} draftId - The ID of the draft to delete
 * @returns {Promise<boolean>} - Success status
 */
function deleteEmailDraft(draftId) {
  return new Promise((resolve, reject) => {
    try {
      // Read draft directory
      const files = fs.readdirSync(draftsDir);
      
      // Find the specific draft file
      const draftFile = files.find(file => file.includes(`email_draft_${draftId}_`));
      
      if (!draftFile) {
        return reject(new Error(`Draft with ID ${draftId} not found`));
      }
      
      const filePath = path.join(draftsDir, draftFile);
      
      // Delete the file
      fs.unlinkSync(filePath);
      
      resolve(true);
    } catch (error) {
      console.error(`Error deleting draft ${draftId}:`, error);
      reject(error);
    }
  });
}

module.exports = {
  createEmailDraft,
  listEmailDrafts,
  getEmailDraft,
  deleteEmailDraft
};
```

</details>

<details>
<summary>**Example Reminder Service Implementation**</summary>

```javascript
// src/reminders.js
const storage = require('./storage');

let reminderInterval;
let isRunning = false;

/**
 * Process any due reminders
 * @private
 */
async function _processDueReminders() {
  try {
    const pendingReminders = await storage.getPendingReminders();
    
    for (const reminder of pendingReminders) {
      console.log(`REMINDER: ${reminder.text}`);
      
      // In a real application, you would also want to:
      // 1. Send notifications to the user
      // 2. Send via appropriate channels (Telegram, email, etc.)
      // 3. Handle recurring reminders
      
      // Mark as completed
      await storage.markReminderCompleted(reminder.id);
    }
  } catch (error) {
    console.error('Error processing reminders:', error);
  }
}

/**
 * Start the reminder service
 * @param {Object} options - Service configuration
 * @returns {Object} - Service control object
 */
function startReminderService(options = {}) {
  if (isRunning) {
    console.log('Reminder service is already running');
    return { stop: stopReminderService };
  }
  
  // Default check interval is every minute (60000 ms)
  const checkInterval = options.checkInterval || 60000;
  
  console.log(`Starting reminder service (checking every ${checkInterval/1000} seconds)`);
  
  // Process any due reminders immediately
  _processDueReminders();
  
  // Set up interval to check for reminders
  reminderInterval = setInterval(_processDueReminders, checkInterval);
  isRunning = true;
  
  return {
    stop: stopReminderService,
    isRunning: () => isRunning
  };
}

/**
 * Stop the reminder service
 */
function stopReminderService() {
  if (!isRunning) {
    console.log('Reminder service is not running');
    return;
  }
  
  if (reminderInterval) {
    clearInterval(reminderInterval);
    reminderInterval = null;
  }
  
  isRunning = false;
  console.log('Reminder service stopped');
}

/**
 * Helper function to parse relative time
 * @param {string} timeStr - Time string (e.g., "5m", "1h", "2d")
 * @returns {Date|null} - Date object or null if invalid
 */
function parseRelativeTime(timeStr) {
  if (!timeStr.match(/^\d+[mhdwM]$/)) {
    return null;
  }
  
  const value = parseInt(timeStr);
  const unit = timeStr.slice(-1);
  
  const now = new Date();
  
  switch (unit) {
    case 'm': // minutes
      now.setMinutes(now.getMinutes() + value);
      break;
    case 'h': // hours
      now.setHours(now.getHours() + value);
      break;
    case 'd': // days
      now.setDate(now.getDate() + value);
      break;
    case 'w': // weeks
      now.setDate(now.getDate() + (value * 7));
      break;
    case 'M': // months
      now.setMonth(now.getMonth() + value);
      break;
    default:
      return null;
  }
  
  return now;
}

/**
 * Create a reminder with support for natural language times
 * @param {string} text - Reminder text
 * @param {string} timeStr - Time string (absolute or relative)
 * @param {string} userId - User identifier
 * @returns {Promise<Object>} - Created reminder info
 */
async function createReminderWithTime(text, timeStr, userId = 'default') {
  let reminderTime;
  
  // Check for relative time format (e.g., "5m", "1h", "2d")
  if (timeStr.match(/^\d+[mhdwM]$/)) {
    reminderTime = parseRelativeTime(timeStr);
    if (!reminderTime) {
      throw new Error('Invalid relative time format');
    }
  } else {
    // Try to parse as absolute time
    reminderTime = new Date(timeStr);
    
    // Check if valid date
    if (isNaN(reminderTime.getTime())) {
      throw new Error('Invalid time format');
    }
  }
  
  // Create the reminder
  const reminderId = await storage.createReminder(
    text,
    reminderTime.toISOString(),
    userId
  );
  
  return {
    id: reminderId,
    text: text,
    remind_at: reminderTime.toISOString(),
    user_id: userId,
    formatted_time: reminderTime.toLocaleString()
  };
}

module.exports = {
  startReminderService,
  stopReminderService,
  parseRelativeTime,
  createReminderWithTime
};
```

</details>

## How to Use These Rules

1. **Copy the rule content**: Click on the dropdown for the specific rule you need
2. **Create a file**: In your project, create a file at <code>.cursor/rules/Rin-v0-step2-[component].cursorignore</code>
3. **Paste the rule**: Paste the copied content into the file
4. **Start developing**: As you work on the component, Cursor will provide guidance based on the rule

You can also chain rules together using the <code>@file</code> reference system:

```
# Include the STT rule for context
@file:.cursor/rules/Rin-v0-step2-stt.cursorignore

# Additional rule content below
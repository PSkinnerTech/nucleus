---
title: "V0 Step 1: Developer & Testing Rules"
navOrder: 1
---

# Rin V0 Step 1: Developer & Testing Rules

This page contains all the Cursor rules you need to implement the Developer & Testing Tools for Rin V0 as outlined in the [Step 1: Developer and Testing](/v0/developer-and-testing) guide.

## Setting Up Cursor Rules

To use these rules in your project, follow these steps:

1. Create a rules directory in your project:
```bash
mkdir -p .cursor/rules
```

2. For each rule below, create a corresponding <code>.cursorignore</code> file in the <code>.cursor/rules</code> directory with the rule content.

For example, to set up the Project Setup rule:
```bash
# Copy the Project Setup rule content
# Create the rule file
touch .cursor/rules/Rin-v0-step1-setup.cursorignore
# Paste the rule content into the file
```

3. You can now use these rules in Cursor to guide your development process. Cursor will automatically apply these rules when you work on relevant files.

## Project Setup Rule

This rule helps you with the initial project setup for the Rin V0 CLI tool.

<details>
<summary>**Click to see the complete Project Setup rule**</summary>

```
# Rin V0 Project Setup Rule
# This rule helps with setting up the initial project structure and dependencies

# Define which files this rule applies to
*.js
*.json
*.env
package.json
package-lock.json
.env

# Rule content below
When helping with the Rin V0 Step 1 project setup:

1. Project Structure Guidelines:
   - Follow the specified directory structure:
     - Rin-cli/
       - src/
         - index.js (CLI entry point)
         - storage.js (Database operations)
       - .env (Environment variables)
       - package.json (Project configuration)
   - Keep the structure simple and flat for this prototype

2. Package Setup:
   - Use npm for package management
   - Required dependencies:
     - commander: For CLI interface
     - dotenv: For environment variable management
     - axios: For HTTP requests
     - openai: For OpenAI API integration
     - sqlite3: For local storage
     - @google-cloud/text-to-speech: For TTS functionality

3. Environment Configuration:
   - Store API keys and credentials in .env file
   - Required environment variables:
     - OPENAI_API_KEY: For OpenAI interaction
     - GOOGLE_CLOUD_CREDENTIALS: Path to Google Cloud credentials file
   - Never hardcode sensitive information in code files
   - Add .env to .gitignore to prevent committing secrets

4. Initialization Process:
   - Use proper error handling when initializing services
   - Validate environment variables are present before using them
   - Provide clear console messages during initialization
   - Use async initialization where appropriate

5. Basic Setup Commands:
   - Recommend proper npm commands for installation and setup
   - Ensure proper file permissions are set
   - Include shebang line in the main CLI file
   - Use npm link for development testing

6. Project Metadata:
   - Set appropriate name, version, and description in package.json
   - Configure bin field for CLI executable
   - Set appropriate license and author information
   - Add start script to package.json

7. Code Style:
   - Use consistent naming conventions (camelCase)
   - Add proper JSDoc comments for functions
   - Use const for values that don't change
   - Separate configuration and implementation
```

</details>

### Implementation Examples

<details>
<summary>**Directory Structure & Setup Commands**</summary>

```bash
mkdir -p Rin-cli/src
cd Rin-cli
npm init -y
npm install commander dotenv axios openai sqlite3 @google-cloud/text-to-speech
touch .env src/index.js src/storage.js
```

</details>

<details>
<summary>**.env File Setup**</summary>

```
# .env
OPENAI_API_KEY=your_openai_key
GOOGLE_CLOUD_CREDENTIALS=/path/to/your/google-credentials.json
```

</details>

<details>
<summary>**package.json Configuration**</summary>

```json
{
  "name": "Rin-cli",
  "version": "0.0.1",
  "description": "Rin CLI - Personal Assistant Prototype",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js"
  },
  "bin": {
    "Rin": "./src/index.js"
  },
  "keywords": ["cli", "assistant", "ai"],
  "author": "Your Name",
  "license": "MIT",
  "dependencies": {
    "commander": "^x.x.x",
    "dotenv": "^x.x.x",
    "axios": "^x.x.x",
    "openai": "^x.x.x", 
    "sqlite3": "^x.x.x",
    "@google-cloud/text-to-speech": "^x.x.x"
  }
}
```

</details>

## CLI Development Rule

This rule helps you build the CLI interface for the Rin V0 prototype using Click.

<details>
<summary>**Click to see the complete CLI Development rule**</summary>

```
# Rin V0 CLI Development Rule
# This rule helps with implementing the CLI interface using Click

# Define which files this rule applies to
*.py
rin/cli.py
rin/commands/*.py

# Include setup rule for context
@file:.cursor/rules/Rin-v0-step1-setup.cursorignore

# Rule content below
When helping with the Rin V0 CLI implementation:

1. CLI Structure Guidelines:
   - Use Click for command line parsing and execution
   - Implement the following commands:
     - ask: For asking Rin a question
     - remember: For viewing past interactions
     - speak: For text-to-speech conversion
   - Keep the CLI entry point clean and modular
   - Add proper descriptions for each command
   - Include version information from package

2. Command Implementation:
   - Each command should have:
     - A clear description
     - Proper argument and option handling
     - Good error handling
     - Clear user feedback
   - For the 'ask' command:
     - Send query to OpenAI API
     - Display the response
     - Store interaction in local storage
   - For the 'remember' command:
     - Retrieve past interactions from storage
     - Display them in a readable format
     - Support pagination if many records exist
   - For the 'speak' command:
     - Convert text to speech using Google Cloud TTS
     - Save audio to file
     - Provide output confirmation

3. Error Handling:
   - Use try/except blocks for error handling
   - Provide useful error messages
   - Check for missing credentials
   - Validate command inputs
   - Use custom exceptions for specific error cases

4. User Experience:
   - Use click.echo for output formatting
   - Include loading indicators for long operations
   - Format output for better readability
   - Set reasonable default values
   - Add help text and examples

5. Code Organization:
   - Use Python classes to structure commands
   - Separate concerns (API calls, command logic, output formatting)
   - Use proper function naming (action verbs for functions)
   - Keep functions focused and small
   - Initialize required services before command execution

6. CLI Entry Point:
   - Use click.group() for command grouping
   - Use click.command() decorators for subcommands
   - Load environment variables early
   - Provide global help and version information
   - Handle keyboard interrupts gracefully
```

</details>

### Implementation Example

<details>
<summary>**CLI Entry Point (rin/cli.py)**</summary>

```python
# rin/cli.py
import os
import click
from dotenv import load_dotenv
from pathlib import Path
import json

from rin.storage import Storage
from rin.llm import OpenAIClient
from rin.tts import TextToSpeech

# Load environment variables
load_dotenv()

# Initialize components
storage = Storage()
llm_client = OpenAIClient()
tts_client = TextToSpeech()

@click.group()
def cli():
    """Rin CLI - Personal Assistant Prototype"""
    pass

@cli.command()
@click.argument('query')
def ask(query):
    """Ask Rin a question"""
    try:
        click.echo("Thinking...")
        # Get response from LLM
        response = llm_client.generate_response(query)
        click.echo(f"Rin: {response}")
        
        # Store interaction in memory
        storage.save_interaction(query, response)
    except Exception as e:
        click.echo(f"Error: {str(e)}")

@cli.command()
@click.option('--limit', '-l', default=10, help='Number of interactions to show')
def remember(limit):
    """Show past interactions"""
    try:
        interactions = storage.get_interactions(limit)
        if not interactions:
            click.echo("No past interactions found.")
            return
        
        click.echo("Past interactions:")
        for i, item in enumerate(interactions):
            click.echo(f"\n--- Interaction {i+1} ---")
            click.echo(f"You: {item['query']}")
            click.echo(f"Rin: {item['response']}")
            click.echo(f"Time: {item['timestamp']}")
    except Exception as e:
        click.echo(f"Error retrieving interactions: {str(e)}")

@cli.command()
@click.argument('text')
@click.option('--output', '-o', default='output.mp3', help='Output filename')
@click.option('--language', '-l', default='en-US', help='Language code')
@click.option('--gender', '-g', default='NEUTRAL', 
              type=click.Choice(['MALE', 'FEMALE', 'NEUTRAL']), 
              help='Voice gender')
def speak(text, output, language, gender):
    """Convert text to speech using Google Cloud TTS"""
    try:
        click.echo("Converting text to speech...")
        tts_client.synthesize_speech(
            text, 
            output_file=output,
            options={
                'language_code': language,
                'gender': gender
            }
        )
        click.echo(f"Audio content written to: {output}")
    except Exception as e:
        click.echo(f"Error with text-to-speech: {str(e)}")

if __name__ == '__main__':
    cli()
```

</details>

## Storage Implementation Rule

This rule helps you implement the SQLite-based storage system for the Rin V0 prototype.

<details>
<summary>**Click to see the complete Storage Implementation rule**</summary>

```
# Rin V0 Storage Implementation Rule
# This rule helps with implementing the SQLite-based storage system

# Define which files this rule applies to
*.py
rin/storage.py
rin/db/*.py
rin/models/*.py

# Include setup rule for context
@file:.cursor/rules/Rin-v0-step1-setup.cursorignore

# Rule content below
When helping with the Rin V0 storage implementation:

1. SQLite Setup:
   - Use Python's built-in sqlite3 module for database operations
   - Create a database in a user-specific location (~/.rin/ folder)
   - Initialize database and tables in the class constructor
   - Use connections and cursors properly
   - Use context managers or proper cleanup for connections

2. Database Schema:
   - Create an interactions table with:
     - id: Primary key, auto-increment
     - query: User's question text
     - response: Assistant's response text
     - timestamp: When the interaction occurred
   - Use appropriate data types for columns
   - Add indexes for frequently queried fields
   - Use TEXT DEFAULT CURRENT_TIMESTAMP for timestamps in SQLite

3. Storage API Design:
   - Implement a Storage class with the following methods:
     - __init__(): Initialize the database connection
     - init_db(): Create necessary tables and indexes
     - save_interaction(query, response): Store a new interaction
     - get_interactions(limit): Retrieve recent interactions
   - Use parameterized queries for security
   - Implement proper error handling with exceptions

4. Error Handling:
   - Use try/except blocks for database operations
   - Close connections properly in the __del__ method
   - Add rollback for transactions
   - Use specific exception types for different errors
   - Provide helpful error messages

5. Data Management:
   - Implement data cleanup for old records
   - Use transactions for multi-statement operations
   - Add proper validation before storing data
   - Return data as dictionaries for easier use
   - Consider data migration strategy for future schema changes

6. Performance Considerations:
   - Use proper indexing for query performance
   - Keep connections open when appropriate
   - Close connections when done
   - Use executemany for batch operations
   - Use connection pooling for concurrent access
```

</details>

### Implementation Example

<details>
<summary>**Storage Module (rin/storage.py)**</summary>

```python
# rin/storage.py
import sqlite3
import os
import json
from pathlib import Path
from datetime import datetime

class Storage:
    def __init__(self):
        # Create data directory in user's home if it doesn't exist
        data_dir = Path.home() / ".rin"
        data_dir.mkdir(exist_ok=True)
        
        # Set up the database
        self.db_path = data_dir / "rin.db"
        self.conn = sqlite3.connect(str(self.db_path))
        self.init_db()
        
        print(f"Local memory initialized at {self.db_path}")
    
    def init_db(self):
        """Initialize the database tables and indexes"""
        cursor = self.conn.cursor()
        
        # Create interactions table if it doesn't exist
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS interactions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                query TEXT NOT NULL,
                response TEXT NOT NULL,
                timestamp TEXT DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Create index on timestamp for faster queries
        cursor.execute('''
            CREATE INDEX IF NOT EXISTS idx_interactions_timestamp 
            ON interactions(timestamp DESC)
        ''')
        
        self.conn.commit()
    
    def save_interaction(self, query, response):
        """Store an interaction in the database
        
        Args:
            query (str): The user's question
            response (str): The assistant's response
            
        Returns:
            int: The ID of the inserted record
        """
        try:
            cursor = self.conn.cursor()
            cursor.execute(
                "INSERT INTO interactions (query, response) VALUES (?, ?)",
                (query, response)
            )
            self.conn.commit()
            return cursor.lastrowid
        except sqlite3.Error as e:
            self.conn.rollback()
            raise Exception(f"Database error: {str(e)}")
    
    def get_interactions(self, limit=10):
        """Retrieve recent interactions from the database
        
        Args:
            limit (int): Maximum number of interactions to retrieve
            
        Returns:
            list: List of interaction dictionaries
        """
        try:
            cursor = self.conn.cursor()
            cursor.execute(
                "SELECT id, query, response, timestamp FROM interactions ORDER BY timestamp DESC LIMIT ?",
                (limit,)
            )
            rows = cursor.fetchall()
            
            # Convert to list of dictionaries
            interactions = []
            for row in rows:
                interactions.append({
                    "id": row[0],
                    "query": row[1],
                    "response": row[2],
                    "timestamp": row[3]
                })
            
            return interactions
        except sqlite3.Error as e:
            raise Exception(f"Database error: {str(e)}")
    
    def cleanup_old_interactions(self, days=30):
        """Remove interactions older than specified days
        
        Args:
            days (int): Number of days to keep
            
        Returns:
            int: Number of records deleted
        """
        try:
            cursor = self.conn.cursor()
            cursor.execute(
                "DELETE FROM interactions WHERE datetime(timestamp) < datetime('now', ?)",
                (f'-{days} days',)
            )
            self.conn.commit()
            return cursor.rowcount
        except sqlite3.Error as e:
            self.conn.rollback()
            raise Exception(f"Database error: {str(e)}")
    
    def __del__(self):
        """Ensure database connection is closed when the object is destroyed"""
        if hasattr(self, 'conn'):
            self.conn.close()
```

</details>

## API Integration Rule

This rule helps you implement API integrations for the Rin V0 prototype, focusing on OpenAI and Google Cloud Text-to-Speech.

<details>
<summary>**Click to see the complete API Integration rule**</summary>

```
# Rin V0 API Integration Rule
# This rule helps with integrating external APIs

# Define which files this rule applies to
*.py
rin/*.py
rin/api/*.py
rin/services/*.py

# Include setup rule for context
@file:.cursor/rules/Rin-v0-step1-setup.cursorignore

# Rule content below
When helping with the Rin V0 API integrations:

1. OpenAI Integration:
   - Use the official openai Python package
   - Set up the API key from environment variables
   - Use the ChatCompletion API for conversations
   - Set a reasonable model (gpt-4 or gpt-3.5-turbo)
   - Create a consistent system prompt for Rin
   - Handle API responses correctly
   - Extract the message content from responses
   - Set appropriate parameters (temperature, max_tokens, etc.)
   - Implement proper error handling for API limits

2. Google Cloud TTS Integration:
   - Use the google-cloud-texttospeech package
   - Set up authentication using credentials file path
   - Choose appropriate voice settings
   - Support multiple languages
   - Select good default audio settings
   - Save audio output to a file
   - Properly handle audio binary data
   - Implement audio format options

3. API Error Handling:
   - Use try/except blocks for error handling
   - Handle network errors
   - Handle rate limiting errors
   - Implement exponential backoff for retries
   - Provide clear error messages to users
   - Log errors for debugging
   - Handle authentication errors
   - Validate inputs before sending to APIs

4. API Security:
   - Never hardcode API keys in source code
   - Use environment variables for credentials
   - Keep credentials file secure
   - Set appropriate permissions for output files
   - Validate and sanitize user input
   - Use HTTPS for all API connections
   - Follow principle of least privilege

5. API Architecture:
   - Create abstraction layers for APIs as Python classes
   - Implement service objects for API calls
   - Separate concerns between APIs and business logic
   - Make API services easily swappable
   - Implement caching where appropriate
   - Use dependency injection for testing

6. Performance Considerations:
   - Implement request timeouts
   - Handle concurrent requests appropriately
   - Consider streaming responses for long outputs
   - Optimize request payload sizes
   - Implement connection pooling when applicable
```

</details>

### Implementation Example

<details>
<summary>**OpenAI Service (rin/llm.py)**</summary>

```python
# rin/llm.py
import os
import time
import openai
from typing import Optional, Dict, Any, List

# Default system prompt for Rin
DEFAULT_SYSTEM_PROMPT = "You are Rin, a helpful personal assistant. Provide concise, accurate, and helpful responses."

class OpenAIClient:
    def __init__(self, api_key: Optional[str] = None, options: Optional[Dict[str, Any]] = None):
        """Initialize the OpenAI client
        
        Args:
            api_key: Optional API key (defaults to environment variable)
            options: Configuration options
        """
        # Use provided API key or get from environment
        self.api_key = api_key or os.getenv("OPENAI_API_KEY")
        if not self.api_key:
            raise ValueError("OpenAI API key is required. Set OPENAI_API_KEY environment variable.")
        
        # Set API key for OpenAI library
        openai.api_key = self.api_key
        
        # Set default options
        self.options = {
            "model": "gpt-4",
            "temperature": 0.7,
            "max_tokens": 500,
            "system_prompt": DEFAULT_SYSTEM_PROMPT,
            "timeout": 30,  # 30 seconds timeout
            "max_retries": 3
        }
        
        # Update with user options if provided
        if options:
            self.options.update(options)
    
    def generate_response(self, query: str) -> str:
        """Generate a response from OpenAI models
        
        Args:
            query: The user's question
            
        Returns:
            The generated response text
        """
        retry_count = 0
        backoff_time = 1  # Start with 1 second backoff
        
        while retry_count <= self.options["max_retries"]:
            try:
                # Create the chat completion
                response = openai.ChatCompletion.create(
                    model=self.options["model"],
                    messages=[
                        {"role": "system", "content": self.options["system_prompt"]},
                        {"role": "user", "content": query}
                    ],
                    temperature=self.options["temperature"],
                    max_tokens=self.options["max_tokens"],
                    timeout=self.options["timeout"]
                )
                
                # Extract and return the message content
                if response.choices and len(response.choices) > 0:
                    return response.choices[0].message.content.strip()
                else:
                    raise Exception("Unexpected empty response from OpenAI API")
                    
            except openai.error.RateLimitError:
                # Handle rate limiting with exponential backoff
                if retry_count < self.options["max_retries"]:
                    print(f"Rate limit exceeded. Retrying in {backoff_time} seconds...")
                    time.sleep(backoff_time)
                    backoff_time *= 2  # Exponential backoff
                    retry_count += 1
                else:
                    raise Exception("Rate limit exceeded. Maximum retries reached.")
                    
            except openai.error.APIError as e:
                # Handle API errors
                if self._is_retryable_error(e) and retry_count < self.options["max_retries"]:
                    print(f"API error: {str(e)}. Retrying in {backoff_time} seconds...")
                    time.sleep(backoff_time)
                    backoff_time *= 2
                    retry_count += 1
                else:
                    raise Exception(f"OpenAI API error: {str(e)}")
                    
            except openai.error.AuthenticationError:
                # No retry for auth errors
                raise Exception("Authentication error: Invalid OpenAI API key")
                
            except openai.error.Timeout:
                # Handle timeout errors
                if retry_count < self.options["max_retries"]:
                    print(f"Request timed out. Retrying in {backoff_time} seconds...")
                    time.sleep(backoff_time)
                    backoff_time *= 2
                    retry_count += 1
                else:
                    raise Exception("Request timed out. Maximum retries reached.")
                    
            except Exception as e:
                # Handle unexpected errors
                raise Exception(f"Error calling OpenAI API: {str(e)}")
    
    def _is_retryable_error(self, error) -> bool:
        """Determine if an error should trigger a retry
        
        Args:
            error: The error to check
            
        Returns:
            True if the error is retryable, False otherwise
        """
        # Server errors are retryable
        if hasattr(error, 'http_status'):
            return error.http_status >= 500
            
        # Network errors are retryable
        if isinstance(error, (openai.error.APIConnectionError, openai.error.ServiceUnavailableError)):
            return True
            
        return False
```

</details>

<details>
<summary>**Text-to-Speech Service (rin/tts.py)**</summary>

```python
# rin/tts.py
import os
from typing import Dict, Any, Optional
from google.cloud import texttospeech

class TextToSpeech:
    def __init__(self, credentials_path: Optional[str] = None):
        """Initialize the Text-to-Speech client
        
        Args:
            credentials_path: Optional path to credentials JSON file
        """
        # Set credentials path if provided
        if credentials_path:
            os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = credentials_path
            
        # Check for credentials
        if not os.getenv("GOOGLE_APPLICATION_CREDENTIALS"):
            raise ValueError("Google Cloud credentials not found. Set GOOGLE_APPLICATION_CREDENTIALS environment variable.")
        
        # Initialize the client
        try:
            self.client = texttospeech.TextToSpeechClient()
        except Exception as e:
            raise Exception(f"Failed to initialize Text-to-Speech client: {str(e)}")
    
    def synthesize_speech(self, text: str, output_file: str = "output.mp3", options: Optional[Dict[str, Any]] = None) -> str:
        """Convert text to speech and save to a file
        
        Args:
            text: The text to convert to speech
            output_file: Path to save the audio file
            options: Voice and audio options
            
        Returns:
            The path to the output file
        """
        # Set default options
        voice_options = {
            "language_code": "en-US",
            "gender": "NEUTRAL",
            "voice_name": None
        }
        
        audio_options = {
            "audio_encoding": "MP3",
            "pitch": 0,
            "speaking_rate": 1.0
        }
        
        # Update with user options if provided
        if options:
            if "language_code" in options:
                voice_options["language_code"] = options["language_code"]
            if "gender" in options:
                voice_options["gender"] = options["gender"]
            if "voice_name" in options:
                voice_options["voice_name"] = options["voice_name"]
            if "audio_encoding" in options:
                audio_options["audio_encoding"] = options["audio_encoding"]
            if "pitch" in options:
                audio_options["pitch"] = options["pitch"]
            if "speaking_rate" in options:
                audio_options["speaking_rate"] = options["speaking_rate"]
        
        try:
            # Set up the text input
            synthesis_input = texttospeech.SynthesisInput(text=text)
            
            # Build the voice request
            voice = texttospeech.VoiceSelectionParams(
                language_code=voice_options["language_code"],
                ssml_gender=getattr(texttospeech.SsmlVoiceGender, voice_options["gender"]),
                name=voice_options["voice_name"]
            )
            
            # Select the audio format
            audio_config = texttospeech.AudioConfig(
                audio_encoding=getattr(texttospeech.AudioEncoding, audio_options["audio_encoding"]),
                pitch=audio_options["pitch"],
                speaking_rate=audio_options["speaking_rate"]
            )
            
            # Perform the synthesis
            response = self.client.synthesize_speech(
                input=synthesis_input,
                voice=voice,
                audio_config=audio_config
            )
            
            # Write the audio content to file
            with open(output_file, "wb") as out:
                out.write(response.audio_content)
                
            return output_file
            
        except Exception as e:
            raise Exception(f"Error synthesizing speech: {str(e)}")
    
    def list_voices(self, language_code: Optional[str] = None) -> List[Dict[str, Any]]:
        """Get available voices
        
        Args:
            language_code: Optional language code to filter voices
            
        Returns:
            List of available voices
        """
        try:
            request = texttospeech.ListVoicesRequest(language_code=language_code)
            response = self.client.list_voices(request=request)
            
            voices = []
            for voice in response.voices:
                voices.append({
                    "name": voice.name,
                    "gender": texttospeech.SsmlVoiceGender(voice.ssml_gender).name,
                    "language_codes": list(voice.language_codes),
                    "natural_sample_rate_hertz": voice.natural_sample_rate_hertz
                })
                
            return voices
            
        except Exception as e:
            raise Exception(f"Error listing voices: {str(e)}")
```

</details>

## Testing and Debugging Rule

This rule helps you test and debug the Rin V0 prototype to ensure it works correctly before moving on to later development stages.

<details>
<summary>**Click to see the complete Testing and Debugging rule**</summary>

```
# Rin V0 Testing and Debugging Rule
# This rule helps with testing and debugging the CLI application

# Define which files this rule applies to
*.py
tests/*.py
test_*.py
conftest.py

# Include setup rule for context
@file:.cursor/rules/Rin-v0-step1-setup.cursorignore

# Rule content below
When helping with testing and debugging the Rin V0 CLI:

1. Manual Testing Approach:
   - Test each command individually with various inputs
   - Test the CLI with valid and invalid environment variables
   - Check for proper error handling and user feedback
   - Test with different input types and edge cases
   - Verify database operations are working correctly
   - Test integration with external APIs
   - Test CLI installation and execution

2. Common Issues to Check:
   - Missing environment variables or configuration
   - Database connection issues
   - API authentication problems
   - Path and permission issues for file operations
   - Command syntax or usage problems
   - Error handling gaps
   - Dependency installation issues
   - Virtual environment setup problems

3. Debugging Techniques:
   - Use print() statements for debugging
   - Use Python's logging module for structured logging
   - Set up Python debugger (pdb) for interactive debugging
   - Check for typos in variable names
   - Verify file paths are correct
   - Use try/except blocks to isolate issues
   - Test API calls in isolation
   - Check database connectivity and queries

4. Environment Setup Validation:
   - Confirm Python version is compatible (3.9+)
   - Verify all dependencies are installed
   - Check that virtual environment is activated
   - Check that API keys are valid and working
   - Confirm database path is writable
   - Verify file system permissions
   - Test network connectivity for API calls

5. Test Scripts and Commands:
   - Create simple test scripts for common operations
   - Use pytest for unit testing
   - Test the CLI in a clean environment
   - Document manual test procedures
   - Create test data for consistent testing
   - Create isolated test environments
   - Implement cleanup routines after tests

6. Documentation for Troubleshooting:
   - Document common errors and solutions
   - Add troubleshooting tips to README
   - Include setup validation steps
   - Document required environment variables
   - Provide example commands and expected output
   - Include contact information for support
```

</details>

### Implementation Example

<details>
<summary>**Testing Script (tests/test_manual.py)**</summary>

```python
#!/usr/bin/env python3
# tests/test_manual.py
import os
import subprocess
import sys
from pathlib import Path

def run_command(cmd):
    """Run a command and return the output"""
    try:
        result = subprocess.run(
            cmd, 
            shell=True, 
            check=True,
            capture_output=True,
            text=True
        )
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f"Command failed with exit code {e.returncode}")
        print(f"Error output: {e.stderr}")
        return None

def main():
    # Define test cases
    tests = [
        {
            "name": "Help command",
            "cmd": "rin --help",
            "expected_in_output": "Usage:"
        },
        {
            "name": "Ask command",
            "cmd": "rin ask \"What is the capital of France?\"",
            "expected_in_output": "Paris"
        },
        {
            "name": "Remember command",
            "cmd": "rin remember",
            "expected_in_output": "Interaction"
        },
        {
            "name": "Speak command",
            "cmd": "rin speak \"Hello world\" -o test-output.mp3",
            "expected_in_output": "Audio content written to",
            "cleanup": lambda: Path("test-output.mp3").unlink(missing_ok=True)
        }
    ]
    
    # Run tests
    print("Running Rin CLI tests...\n")
    
    passed = 0
    failed = 0
    
    for test in tests:
        print(f"Test: {test['name']}")
        
        # Execute the command
        output = run_command(test["cmd"])
        
        if output is None:
            print(f"❌ FAILED: Command execution error")
            failed += 1
            continue
        
        # Check if expected text is in the output
        if test["expected_in_output"] in output:
            print(f"✅ PASSED: Output contains \"{test['expected_in_output']}\"")
            passed += 1
        else:
            print(f"❌ FAILED: Output does not contain \"{test['expected_in_output']}\"")
            print(f"Output: {output.strip()}")
            failed += 1
        
        # Run cleanup function if provided
        if "cleanup" in test:
            test["cleanup"]()
            print("Cleaned up test files")
        
        print()  # Add empty line between tests
    
    # Print summary
    print(f"Test summary: {passed} passed, {failed} failed")
    return 1 if failed > 0 else 0

if __name__ == "__main__":
    sys.exit(main())
```

</details>

<details>
<summary>**Unit Test Example (tests/test_storage.py)**</summary>

```python
# tests/test_storage.py
import pytest
import os
import sqlite3
from pathlib import Path
import tempfile
import shutil

# Import the Storage class to test
from rin.storage import Storage

@pytest.fixture
def temp_home_dir():
    """Create a temporary home directory for testing"""
    original_home = os.environ.get("HOME")
    with tempfile.TemporaryDirectory() as temp_dir:
        # Set HOME to the temp directory
        os.environ["HOME"] = temp_dir
        yield temp_dir
        # Restore original HOME
        if original_home:
            os.environ["HOME"] = original_home

def test_storage_initialization(temp_home_dir):
    """Test that the Storage class initializes correctly"""
    storage = Storage()
    
    # Check that the database directory was created
    db_dir = Path(temp_home_dir) / ".rin"
    assert db_dir.exists()
    assert db_dir.is_dir()
    
    # Check that the database file was created
    db_path = db_dir / "rin.db"
    assert db_path.exists()
    assert db_path.is_file()
    
    # Check that we can connect to the database
    conn = sqlite3.connect(str(db_path))
    cursor = conn.cursor()
    
    # Check that the interactions table exists
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='interactions'")
    result = cursor.fetchone()
    assert result is not None
    assert result[0] == "interactions"
    
    # Clean up
    conn.close()

def test_save_and_retrieve_interaction(temp_home_dir):
    """Test saving and retrieving interactions"""
    storage = Storage()
    
    # Save a test interaction
    test_query = "What is the meaning of life?"
    test_response = "42"
    row_id = storage.save_interaction(test_query, test_response)
    
    # Check that we got a valid row ID
    assert row_id is not None
    assert row_id > 0
    
    # Retrieve interactions
    interactions = storage.get_interactions()
    
    # Check that we got our test interaction back
    assert len(interactions) == 1
    assert interactions[0]["query"] == test_query
    assert interactions[0]["response"] == test_response
    assert "timestamp" in interactions[0]

def test_cleanup_old_interactions(temp_home_dir):
    """Test cleaning up old interactions"""
    storage = Storage()
    
    # Save some test interactions
    storage.save_interaction("Test 1", "Response 1")
    storage.save_interaction("Test 2", "Response 2")
    storage.save_interaction("Test 3", "Response 3")
    
    # Check that we have 3 interactions
    interactions = storage.get_interactions()
    assert len(interactions) == 3
    
    # Manually adjust the timestamp of the first interaction to be older
    db_path = Path(temp_home_dir) / ".rin" / "rin.db"
    conn = sqlite3.connect(str(db_path))
    cursor = conn.cursor()
    cursor.execute(
        "UPDATE interactions SET timestamp = datetime('now', '-40 days') WHERE id = ?",
        (interactions[0]["id"],)
    )
    conn.commit()
    conn.close()
    
    # Clean up interactions older than 30 days
    deleted_count = storage.cleanup_old_interactions(days=30)
    
    # Check that we deleted 1 interaction
    assert deleted_count == 1
    
    # Check that we have 2 interactions left
    interactions = storage.get_interactions()
    assert len(interactions) == 2
```

</details>

## How to Use These Rules

1. **Copy the rule content**: Click on the dropdown for the specific rule you need
2. **Create a file**: In your project, create a file at <code>.cursor/rules/Rin-v0-step1-[component].cursorignore</code>
3. **Paste the rule**: Paste the copied content into the file
4. **Start developing**: As you work on the component, Cursor will provide guidance based on the rule

You can also chain rules together using the <code>@file</code> reference system:

```
# In other rules, include the setup rule for context
@file:.cursor/rules/Rin-v0-step1-setup.cursorignore

# Additional rule content below
```